
%------------------------------------------------------------------------
\chapter{\cmd{init}}
\label{ch:init}
%------------------------------------------------------------------------
% $Id: init.tex,v 1.1.1.2 2004-03-22 12:59:26 dmytro Exp $

        \begin{verse}\it
Uuno on numero yksi \\
        \rm\end{verse}

	\noindent
	
	В цьому розд╕л╕ опису╓ться процес \cmd{init}. Процес
	\cmd{init} ╓ першим процесом користувацького р╕вня роботи,
	який старту╓ться ядром. В╕н ма╓ багато важливих обов'язк╕в,
	таких як стартування \cmd{getty} для того, щоб користувач╕
	могли ре╓струватися в систем╕. \cmd{init} запуска╓ робоч╕
	р╕вн╕ в систем╕ та п╕клу╓ться (всиновлю╓) про процеси, як╕
	стали сиротами. Цей розд╕л поясню╓, як можна сконф╕╜урувати
	\cmd{init} та використати р╕зноман╕тн╕ можливост╕ робочих
	р╕вн╕в.

\index{init|див.{/sbin/init}}
\index{демони!init|див.{/sbin/init}}
\index{/sbin/init}
	
\section{\cmd{init} приходить першим}

	\cmd{init} - це одна з тих абсолютно необх╕дних програм, як╕
	житт╓во необх╕дн╕ для роботи Л╕накса. Але Ви можете абсолютно
	забути про \cmd{init} ╕ не турбуватися про його роботу. Добре
	в╕длагоджена (куплена чи ╕ншим чином придбана) верс╕я Л╕накса
	постача╓ться з конф╕╜урац╕╓ю \cmd{init}'а, яка буде добре
	працювати з б╕льш╕стю систем. В таких системах робити будь-яку
	настройку для \cmd{init}'а абсолютно непотр╕бно.  Про
	\cmd{init} згадують т╕льки тод╕, коли через посл╕довний порт
	або модем треба п╕дключити до системи терм╕нал, щоб
	п╕дключатися до сво╓╖ системи ззовн╕ (але не для того, щоб
	дзвонити з свого комп'ютера на ╕нший), або ж тод╕, коли треба
	зм╕нити стартовий робочий р╕вень.

	П╕сля того, як ядро стартувало себе (тобто прочитане в
	пам'ять, почало працювати та провело ╕н╕ц╕ал╕зац╕ю драйвер╕в
	та структур даних), воно (ядро) зак╕нчу╓ роботу над самим
	собою ╕ завершу╓ процес старту системи, запускаючи на
	виконання процес, що в╕дноситься до користувацього р╕вня
	роботи \intnote{user level program} - процес \cmd{init}. Таким
	чином, процес \cmd{init} - це завжди самий перший процес
	користувацького р╕вня роботи (номер процесу \cmd{init}'а
	завжди ╓~1).

	Ядро шука╓ \cmd{init} в к╕лькох м╕сцях - тих як╕ в минулому
	використовувалися для нього. Але в╕рне м╕сце для
	\cmd{init}'а в Л╕накс╕ - це \fn{/sbin/init}. Якщо ядро не може
	запустити \cmd{init}, воно намага╓ться стартувати
	\cmd{/bin/sh}, ╕ якщо нав╕ть це не спрацьову╓, система
	зда╓ться ╕ ╖╖ старт не в╕дбува╓ться.
	
	Колии \cmd{init} почина╓ свою роботу, в╕н продовжу╓ початий
	ядром процес завантаження. \cmd{init} викону╓ деяк╕
	адм╕н╕стративн╕ кроки, так╕, як перев╕рка файлових систем,
	очистка \fn{/tmp}, запуска╓ р╕зноман╕тн╕ серв╕си системи та
	старту╓ \cmd{getty} для кожного терм╕налу та в╕ртуально╖
	консол╕, на яких дозволена робота користувачам
	(див. розд╕л~\ref{ch:logins}).

	П╕сля того, як ╕з стартом системи зак╕нчено, \cmd{init}
	сл╕дку╓ за терм╕налами. Коли один з користувач╕в зак╕нчу╓
	роботу на терм╕нал╕, \cmd{init} перезапуска╓ \cmd{getty} на
	цьому терм╕нал╕, щоб в систем╕ м╕г заре╓струватися наступний
	користувач. Кр╕м того \cmd{init} усиновлю╓ процеси-сироти.
	Коли один процес старту╓ ╕нший процес, то цей другий процес
	назива╓ться дитиною першого. Якщо процес-батько вмира╓
	(зак╕нчу╓ свою роботу) ран╕ше, н╕ж помре його дитина, процес
	\cmd{init} митт╓во усиновлю╓ цю дитину - вона ста╓ дитиною
	\cmd{init}'а. Пояснення цього дуже техн╕чне, але варто про це
	знати, оск╕льки це да╓ розум╕ння списк╕в процес╕в ╕ граф╕в
	дерев процес╕в.\footnote{\cmd{init}'у самому вмирати не
	дозволено. Його не можна вбити нав╕ть сигналом SIGKILL.}
	
	╤сну╓ к╕лька р╕зних вар╕ат╕в \cmd{init}'а. Б╕льш╕сть Л╕накс╕в
	користуються вар╕антом, в╕домим як \cmd{sysvinit} (написаний
	написаний М╕╜елем ван Смуренбур╜ом\intnote{Miquel van
	Smoorenburg}. В╕н базу╓ться на дизайн╕ \cmd{init}'а System
	V. BSD верс╕╖ Юн╕кс╕в мають ╕нший \cmd{init}. Основна
	в╕дм╕нн╕сть - в робочих р╕внях. System V ма╓ робоч╕ р╕вн╕, BSD
	Юн╕кси - н╕. Ця р╕зниця - несутт╓ва, але ми будемо
	розглядати т╕льки \cmd{sysvinit}.
	
\section{Настройка  \cmd{init} для старту \cmd{getty}: файл \fn{/etc/inittab}}

	На початку роботи \cmd{init} чита╓ конф╕╜урац╕йний файл
	\fn{/etc/inittab}. П╕д час роботи системи в╕н не буде б╕льше
	звертатися до цього файлу ╕ перечита╓ його, т╕льки якщо йому
	послано сигнал HUP\footnote{наприклад, якщо Ви як root
	викона╓те команду \cmd{kill~-HUP~1}}. Дякуючи цьому не
	потр╕бно перегружати систему, п╕сля зм╕н в \fn{/etc/inittab}.

	Синтаксис файлу \fn{/etc/inittab} трохи заплутаний, тому ми
	почнем з простого випадку конф╕╜урац╕╖ л╕н╕й
	\cmd{getty}. Рядки в файл╕ \fn{/etc/inittab} складаються з
	чотирьох пол╕в розд╕лених двокрапками:
		%
\begin{quote}
\textsl{id:робоч╕ р╕вн╕:д╕я:процес}
\end{quote}
		%
	Поля описан╕ трохи дал╕. Додатково \fn{/etc/inittab} може мати
	пуст╕ рядки та рядки, як╕ починаються символом
	номера\intnote{В анл╕йськ╕й мов╕. Укра╖нською можна було б
	сказати "<знаком д╕╓з">} - (`verb|\#|'). Обидва типи таких
	рядк╕в ╕гноруються. 

	\begin{description}

	\item[id] Це поле визнача╓ назву рядка. Для рядк╕в
			конф╕╜урац╕╖ \cmd{getty} воно вказу╓ терм╕нал,
			де працю╓ даний \cmd{getty} (л╕тери, що йдуть
			п╕сля \fn{/dev/tty} в назв╕ спец╕ального файлу
			пристрою). В ╕нших випадках це поле не ма╓
			н╕якого значення (кр╕м х╕ба що обмежень по
			довжин╕). Але вс╕ рядки в \cmd{/etc/inittab}
			повинн╕ мати в╕дм╕нн╕ м╕ж собою поля.

	\item[робоч╕ р╕вн╕] 
			Т╕ робоч╕ р╕вн╕, на яких даний рядок треба
			виконувати. Робоч╕ р╕вн╕ задаються у вигляд╕
			однозначних чисел (цифр) без розд╕лових
			знак╕в. (Робоч╕ р╕вн╕ описан╕ в наступному
			розд╕л╕). 
	
	\item[д╕я]	
			Визнача╓ спос╕б роботи даного рядка. Якщо в
			цьому пол╕ вказано \texttt{respawn}, то
			програма буде запускатися заново кожного разу,
			коли вона зак╕нчить роботу, якщо ж вказано
			\texttt{once} - програма викона╓ться один
			раз. 
			
	\item[процес]	Команда для виконання.
			
	\end{description}

	Для того, щоб \cmd{getty} стартував на першому в╕ртуальному
	терм╕нал╕ (\fn{/dev/tty1}) на вс╕х нормальних
	багатокористувацьких робочих р╕внях (2--5) сл╕д додади до
	\cmd{inittab} такий рядок:
		%
\begin{quote}\tt
1:2345:respawn:/sbin/getty 9600 tty1
\rm\end{quote}
		%

	Перше поле вказу╓, що це рядок для \fn{/dev/tty1}. В другому
	кажеться, що команда повинна виконуватися на робочих р╕внях 2,3,4 та
	5. Трет╓ поле вказу╓, що п╕сля зак╕нчення роботи ц╕╓╖
	програми, ╖╖ треба перезапустити знову (тобто, користувач може
	заре╓струватися в систем╕, вийти з системи ╕ буде мати
	можлив╕сть заре╓струватися знову). Останн╓ поле рядка викону╓
	команду \cmd{getty} на першому в╕ртуальному
	терм╕нал╕.\footnote{Р╕зн╕ верс╕╖ \cmd{getty} можуть працювати
	по р╕зному, тому перш, н╕ж зм╕нювати рядок, прочитайте
	стор╕нку п╕дказки для дано╖ команди. ╤ саме головне -
	прочитайте ╖╖ саме для то╖ команди, якою Ви користу╓тесь.}

	Якщо Вам потр╕бно додати терм╕нал╕в чи модем╕в в систему, Вам
	потр╕бно додати б╕льше рядк╕в в \cmd{/etc/inittab} - по одному
	рядку на кожен терм╕нал чи модем. Як це зробити див╕ться в
	п╕дказках по \man{init}(8), \man{inittab}(5) та
	\man{getty}(8). 

	Якщо вказана в \fn{inittab} програма не може стартувати в╕рно,
	вона помира╓ зразу ж п╕сля старту. \cmd{init} настро╓ний
	стартувати ╖╖ знову. Програма старту╓, вмира╓, старту╓ знову,
	зупиня╓ться... ╕ т.д. Це займа╓ страшенну к╕льк╕сть системних
	ресурс╕в. Тому \cmd{init} веде обл╕к к╕лькост╕ раз╕в, що та
	чи ╕нша програма стартувала, ╕ якщо це трапля╓ться занадто
	часто, в╕н затриму╓ старт на п'ять хвилин.
	
\section{Р╕вн╕ роботи}

	\defin{Робочим р╕внем} називають стан, в якому перебува╓
	\cmd{init} та система в ц╕лому, ╕ який визнача╓, як╕ саме
	системн╕ серв╕си знаходяться в робот╕. Робоч╕ р╕вн╕
	визначаються номерами, див. таблицю~\ref{ref:run-levels}. Ще
	дос╕ не прийшли до згоди, щодо того, як саме нумерувати робоч╕
	р╕вн╕ в╕д 2 до 5. Деяк╕ системн╕ адм╕н╕стратори використовують
	робоч╕ р╕вн╕ для того, щоб визначити, як╕ п╕дсистеми працюють.
	Тобто: чи працю╓ X, мережа ╕ т.д. ╤нш╕ стартують чи зупиняють
	п╕дсистеми одну по одн╕й без зм╕ни робочих р╕вн╕в.  ╥м
	зда╓ться, що робоч╕ р╕вн╕ - це вже занадто для ╖хньо╖
	системи. Вам треба визначатися з цим самост╕йно. Або, може,
	нав╕ть краще залишити все так, як воно вже ╓ в т╕й верс╕╖
	Л╕накса, що Ви ма╓те.

	
		\begin{table}[h]
		\caption{Run level numbers}
		\label{tab:run-levels}
		\begin{center}
		\begin{tabular}{ll}
		\hline
		0 & Halt the system. \\
		1 & Single-user mode (for special administration). \\
		2--5 & Normal operation (user defined). \\
		6 & Reboot. \\
		\hline
		\end{tabular}
		\end{center}
		\end{table}

	Робоч╕ р╕вн╕ конф╕╜уруються в \fn{/etc/inittab}	такими рядками:
		%
\begin{quote}\tt
l2:2:wait:/etc/init.d/rc 2
\rm\end{quote}
		%
	
	Перше поле тут - це дов╕льна етикетка. Друге показу╓, що цей
	рядок в╕дноситься до другого робочого р╕вня. Трет╓ поле
	вказу╓, що \cmd{init} повинен дочекатися, поки зак╕нчиться
	виконання команди, дано╖ в четвертому пол╕. В даному випадку
	команда \fn{/etc/init.d/rc} викону╓ скрипт, який викону╓ вс╕
	команди (запуска╓ необх╕дн╕ демони та системи), як╕ необх╕дно
	виконати для робочого р╕вня 2.
	
	Команда в четвертому пол╕ ╕ викону╓ всю ту роботу, яка
	необх╕дна для встановлення робочого р╕вня. Вона встановлю╓
	серв╕си, як╕ ще не працюють, та зупиня╓ серв╕си, як╕ не
	повинн╕ працювати на даному робочому р╕вн╕. Що це за команда,
	та як конф╕╜уруються р╕зн╕ робоч╕ р╕вн╕, залежить в╕д того,
	яку саме систему Ви ма╓те.
	
	При старт╕ \cmd{init} шука╓ в \cmd{/etc/inittab} рядок, який
	вказу╓ основний робочий р╕вень\intnote{default run level}: 
		%
\begin{quote}\tt
id:2:initdefault:
\rm\end{quote}
		%
	Можна вказати, що \cmd{init} повинен завантажити систему не в
	основний робочий р╕вень, а в якийсь ╕нший. Це робиться за
	допомогою надання командного параметра для ядра, такого як
	\texttt{single} або \texttt{emergency}.\footnote{Параметри
	ядру можна передати за допомогою
	LILO. Див. розд╕л~\ref{sec:single-user-mode}} Це да╓ змогу
	вв╕йти в однокористувацький режим (робочий р╕вень 1), який
	описано в розд╕л╕~\ref{sec:single-user-mode}.
	
	П╕д час роботи системи робочий р╕вень можна зм╕нити за
	допомогою команди \cmd{telinit}. При зм╕н╕ робочого р╕вня,
	\cmd{init} викону╓ в╕дпов╕дн╕ команди ╕з файлу
	\fn{/etc/inittab}.
	

\section{Спец╕альн╕ конф╕╜урац╕╖ в \fn{/etc/inittab}}

	\fn{/etc/inittab} ма╓ деяк╕ спец╕альн╕ можливост╕, як╕
	дозволяють \cmd{init}'у реагувати на в╕дпов╕дн╕ умови. Ц╕
	спец╕альн╕ функц╕ональн╕ можливост╕ позначен╕ спец╕альним
	ключовим словом в третьому пол╕. Деяк╕ приклади:
	
	\begin{description}
	\item[\texttt{powerwait}]

		Команда, яка викону╓ться \cmd{init}'ом в раз╕, коли
		пропада╓ напруга в мереж╕. Да╓ можлив╕сть безпечно
		вимкнути систему при раптовому зникненн╕ напруги. Для
		цього повинен використовуватися резервний блок
		живлення (UPS), ╕ програма, яка сл╕дку╓ за UPS. Ця
		програма пода╓ \cmd{init}'у сигнал, що напруга
		в мереж╕ зникла.
				
	\item[\texttt{ctrlaltdel}]

		Команда, яка викону╓ться \cmd{init}'ом, коли
		користувач натиска╓ {\tt control-alt-del} на
		клав╕атур╕ консол╕. Зважте, що системний
		адм╕н╕стратор, зам╕сть перегрузки, може приписати ╕ншу
		д╕ю для клав╕ш {\tt control-alt-del}. Наприклад,
		просто ╕гнорувати - якщо система знаходиться в
		загально доступному м╕сц╕.\footnote{Чи стартувати
		\cmd{nethack}.}

	\item[\texttt{sysinit}]
		Команда, яка викону╓ться п╕д час завантаження системи. Ця
		команда найчаст╕ше стира╓ \fn{/tmp}.

	\end{description}

	Список, наведений вище, не виключний. Щоб д╕знатися про вс╕
	можливост╕, див╕ться стор╕нку п╕дказки \man{inittab}(5) для
	свого Л╕накса.

\section{Завантаження в однокористувацький режим}
\label{sec:single-user-mode}

	Важливим робочим р╕внем ╓ \defin{однокористувацький режим
	роботи} (робочий р╕вень~1). Звичайно т╕льки системний
	адм╕н╕стратор може користуватися машиною в однокористувацькому
	режим╕ ╕ працю╓ р╕вно ст╕льки системних серв╕с╕в, ск╕льки це
	необх╕дно для п╕дтримання системи в робочому стан╕.
	Однокористувацький режим потр╕бен для виконання к╕лькох
	системних функц╕й,\footnote{скор╕ше всього Ви не будете
	користуватися ним для гри в \cmd{nethack}}. Наприклад, для
	виконання \cmd{fsck} на розд╕л╕ \fn{/usr} потр╕бно
	в╕дмонтувати даний п╕дрозд╕л, але цього не можна зробити, якщо
	не зупинен╕ практично вс╕ системн╕ серв╕си.

	Працюючу систему можна перевести в однокористувацький режим за
	допомогою команди \cmd{telinit}, ╕ вказати команд╕ параметр
	1. При завантаженн╕ цього ж можна добитися, вказавши ядру ключове
	слово \texttt{single} або \texttt{emergency} в командному
	рядку ядра. Ядро, в свою чергу, переда╓ цей командний рядок
	дал╕ - до \cmd{init}'а. \cmd{init} зрозум╕╓, що систему не треба 
	грузити  в основний робочий режим. Як саме Ви переда╓те
	командний рядок ядру залежить в╕д того, як Ваша система
	завантажу╓ться.

	╤нколи необх╕дно завантажитись в однокористувацький режим, для
	того, щоб виконати команду \cmd{fsck} вручну, ще до того, як
	що-небудь змонтоване. Або тод╕, коли що-небудь негаразд  ╕з
	файловою системою \cmd{/usr}. Будь-як╕ д╕╖ над з╕псованою
	файловою системою приведуть т╕льки до того, що вона буде
	з╕псована ще б╕льше - тобто \cmd{fsck} треба виконувати
	якомого ран╕ше.
	

	Якщо при завантаженн╕ системи \cmd{fsck} вида╓ серйозн╕ помилки,
	\cmd{init} автоматично переведе систему в однокористувацький
	режим. Це робиться щоб запоб╕гти використанню системи ╕з
	з╕псованою файловою системою, яку \cmd{fsck} не спроможний
	в╕дремонтувати автоматично. Випадки такого псування в╕дносно
	р╕дк╕ ╕ зв'язан╕ ╕з з╕псованим диском чи експериментальною
	верс╕╓ю ядра, але до них теж треба бути готовими.
		
	Нормально настро╓на система, завантажившись в однокористувацький
	режим, перш, н╕ж запустити командну оболонку, повинна спитати пароль
	користувача \texttt{root}. Без паролю дуже просто, надрукувавши
	простенький рядок в LILO, отримати доступ до вс╕╓╖ системи як
	\texttt{root}. (Але якщо файл \fn{/etc/passwd} був пошкоджений
	при авар╕╖ файлово╖ системи, Ви не зможете вв╕йти в свою
	систему, ╕ на цей випадок краще мати п╕д руками авар╕йну
	завантажувальну дискету.)
	


