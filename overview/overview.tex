%--------------------------------------------------------------------
%\chapter[Огляд системи]{Огляд системи Л╕накс}
\chapter{Огляд системи Л╕накс}
\label{chap:overview}
%--------------------------------------------------------------------

        \begin{verse}\it
	Подивився Владика на все, що в╕н зробив, \\
	╕ побачив, що це було гарно. \\
	Genesis 1:31 \\
        \rm\end{verse}

	\noindent Цей розд╕л да╓ загальний огляд системи Л╕накс. На
	початку розд╕лу описан╕ головн╕ послуги, як╕ надаються
	операц╕йною системою. П╕сля цього описан╕ (практично без
	будь-яких подробиць) програми, як╕ надають ц╕ послуги. Мета
	цього розд╕лу - надати загальне розум╕ння системи в ц╕лому, з
	тим, щоб кожна окрема частина пот╕м була би описана в окремому
	розд╕л╕.
	

\section{Р╕зн╕ складов╕ частини операц╕йно╖ системи}

	Операц╕йна система Юн╕кс склада╓ться з \defin{ядра} та деяких
	\defin{системних програм}. Кр╕м цього ╕снують також
	\defin{прикладн╕ програми}, що повинн╕ робити основну
	роботу. Ядро ╓ серцем операц╕йно╖ системи\footnote{ Фактично,
	воно часто помилково вважа╓ться самою операц╕йною системою,
	але це не так. Операц╕йна система нада╓ набагато б╕льше
	послуг, н╕ж звичайне ядро.}. Воно веде обл╕к файл╕в на диску,
	запуска╓ програми ╕ викону╓ ╖х по черз╕, вид╕ля╓ пам'ять та
	╕нш╕ необх╕дн╕ ресурси р╕зноман╕тним процесам, отриму╓ пакети
	з мереж╕ та переда╓ пакети в мережу, тощо. Ядро мало що робить
	саме по соб╕, але воно забезпечу╓ необх╕дн╕ засоби, за
	допомогою яких вс╕ ц╕ послуги можуть надаватися. Кр╕м цього
	воно також вс╕м забороня╓ програмам доступ безпосередньо до
	апаратури, змушуючи кожного користуватися т╕льки наданими
	ядром засобами. Таким чином, ядро забезпечу╓ деякий захист
	одних користувач╕в в╕д ╕нших. Вс╕ засоби, що надаються ядром,
	доступн╕ при використанн╕ \defin{системних
	виклик╕в}\intnote{system calls}; див. стор╕нки п╕дказок (man
	pages) з розд╕лу 2 для б╕льш повно╖ ╕нформац╕╖ з цього.


\index{ядро}
\index{операц╕йна система}
\index{системна програма}
\index{прикладна програма}
\index{системний виклик}

	Системн╕ програми користуються засобами, що ╖х нада╓ ядро для
	того, щоб виконувати р╕зноман╕тн╕ функц╕╖, т╕, як╕ вимагаються
	в╕д операц╕йно╖ системи. Системн╕ програми, так само, як ╕ вс╕
	╕нш╕ програми в систем╕, працюють "<на вершин╕ ядра"> в
	режим╕, який звуть \defin{режимом користувача} \intnote{user mode}.
	
	Р╕зниця м╕ж системною програмою та прикладною поляга╓ в ╖х
	нам╕рах: прикладн╕ програми нам╕ряються принести корисн╕
	результати (чи насолодження в╕д гри, якщо це ╕грова програма),
	в той час, як системн╕ програми нам╕ряються зробити так, щоб
	система працювала. Текстовий редактор - це прикладна програма,
	\cmd{telnet} - це системна програма. Р╕зниця часто дуже
	розпливчаста, ╕ ╓ житт╓вою т╕льки для запеклих	каталог╕затор╕в.

\index{режим користувача}

	Операц╕йна система також може мати комп╕лятори та в╕дпов╕дн╕
	╖м б╕бл╕отеки (GCC та б╕бл╕отека С╕ в Л╕накс╕, наприклад), хоча
	не обов'язково кожна мова програмування повинна бути частиною
	операц╕йно╖ системи. Документац╕я та ╕гри також можуть
	належати до операц╕йно╖ системи. Традиц╕йно операц╕йна система
	визначалася зм╕стом дискет чи стр╕чок для установки. У випадку
	з Л╕наксом - це визначення не наст╕льки ч╕тке, бо Л╕накс
	розпорошений по вс╕х серверах FTP по ц╕лому св╕ту.

\index{GCC}
\index{мови програмування}
\index{комп╕лятор С╕}
\index{документац╕я}
\index{╕гри}

\section{Важлив╕ частини ядра}

	Ядро Л╕накса склада╓ться з к╕лькох важливих частин: менеджера
	процес╕в, менеджера пам'ят╕, драйвер╕в пристро╖в, драйвер╕в
	файлових систем, менеджера мереж╕ та р╕зноман╕тних шматочк╕в
	та частин. Рисунок~\ref{fig:kernel-overview} показу╓ деяк╕ з
	них. 

\index{менеджер процес╕в}
\index{менеджер пам'ят╕}
\index{драйвер апаратури}
\index{драйвер файлово╖ системи}
\index{менеджер мереж╕}

\begin{figure}[htb]
\begin{center}
\includegraphics{overview/overview-kernel.ps}
\end{center}
\caption{Деяк╕ з важлив╕ших частин ядра Л╕накса.}
\label{fig:kernel-overview}
\end{figure}

	Можливо найважлив╕шими частинами ядра (н╕що ╕нше не працю╓ без
	них) ╓ менеджер пам'ят╕ та менеджер процес╕в. Менеджер пам'ят╕
	п╕клу╓ться про вид╕лення пам'ят╕ та областей своп╕нгу для
	процес╕в, частин ядра та для буфера кешу. Менеджер процес╕в
	створю╓ процеси та в╕дтворю╓ багатозадачний режим роботи
	перемиканням активних процес╕в в процесор╕.

\index{область своп╕нгу}
\index{буфер кешу}
\index{багатозадачн╕сть}

	Найнижчий р╕вень ядра склада╓ться з драйвер╕в вс╕х тих
	пристро╖в, як╕ воно п╕дртиму╓. Через те, що в св╕т╕ повно
	р╕зноман╕тних пристро╖в, драйвер╕в теж багато. Дуже часто
	╕снують багато р╕зноман╕тних апаратних засоб╕в, що виконують
	под╕бн╕ функц╕╖, але в╕др╕зняються тим, як вони керуються з
	боку програмного забезпечення. Под╕бност╕ р╕зних драйвер╕в
	часто роблять можливою розробку "<узагальнених клас╕в">
	драйвер╕в, кожен з яких викону╓ сво╖ функц╕╖. Кожен член
	такого класу ма╓ схожий ╕нтерфейс з ╕ншими частинами ядра, але
	в╕др╕зня╓ться тими частинами, як╕ потребуються для реал╕зац╕╖
	апаратних функц╕й. Наприклад, вс╕ драйвери диск╕в схож╕ м╕ж собою (з
	точки зору ядра), тобто вс╕ вони мають так╕ операц╕╖, як
	"<╕н╕ц╕ал╕зувати диск">, "<прочитати сектор N"> та "<записати
	сектор N">.

	Деяк╕ програмн╕ послуги, що надаються ядром, мають под╕бн╕
	властивост╕, ╕ через це ╖х можна абстрагувати в
	класи. Наприклад, р╕зноман╕тн╕ протоколи зв'язку через мережу
	вид╕лилися в один програмний ╕нтерфейс, що носить назву "<BSD
	socket library"> або "<б╕бл╕отека сокет╕в (розеток)
	BSD">. ╤ншим зразком може служити \defin{в╕ртуальна файлова
	система} (ВФС або VFS, virtual file system) "--- абстрактний
	прошарок, що в╕дд╕ля╓ операц╕╖, як╕ виконуються над файлами
	в╕д ╖х конкретного вт╕лення. Кожний окремо взятий тип файлово╖
	системи ма╓ в╕дм╕нне вт╕лення для кожно╖ окремо взято╖
	файлово╖ операц╕╖. Алк коли деяка ╕стота (ф╕зична особа або
	процес) намага╓ться використати файлову систему, запит до
	файлово╖ системи проходить через ВФС, яка, в свою чергу,
	перенаправля╓ такий запит до драйвера конкретно╖ файлово╖
	системи.

\index{в╕ртуальна файлова система}
\index{BSD}
\index{розетка, сокет}

\section{Основн╕ послуги в систем╕ Юн╕кс}

	Цей розд╕л да╓ опис деяких ╕з найб╕льш важливих послуг, як╕
	надаються системою Юн╕кс. Ц╕ послуги з б╕льшими подробицями
	описан╕ в п╕зн╕ших розд╕ладх.
	
\subsection{\cmd{init}}

	Найперша ╕ найважлив╕ша послуга в Юн╕кс╕ нада╓ться процесом
	\cmd{init}.  \cmd{init} ╓ першим процесом в кожн╕й систем╕
	Юн╕кс, ╕ старт \cmd{init} ╓ останн╕м кроком, який викону╓
	ядро, коли воно завантажу╓ться. П╕сля свого старту \cmd{init}
	продовже╓ процес завантаження системи, виконуючи р╕зноман╕тн╕
	задач╕, потр╕бн╕ при старт╕ системи, так╕ як перев╕рка та
	монтування файлових систем, старт демон╕в (фонових процес╕в),
	тощо.

\index{/sbin/init}
\index{монтування файлових систем}
\index{процес завантаження}

	Точний список тих крок╕в, як╕ робляться \cmd{init}'ом
	насправд╕ залежить в╕д того, до якого типу в╕н в╕дноситься. ╢
	к╕лька р╕зноман╕тностей доступних для вибору. \cmd{init} як
	звичайно забезпечу╓ \defin{однокористувацький
	режим}\intnote{single user mode}, в якому н╕хто не може
	заре╓струватися в систему ╕ користувач \cmd{root} користу╓ться
	командною оболонкою на системн╕й консол╕; звичайний режим
	роботи ма╓ назву \defin{багатокористувацького
	режиму}\intnote{multi user mode}. Деяк╕ верс╕╖ Юн╕кс╕в
	узагальнюють ц╕ поняття п╕д назвою \defin{"<робочих р╕вн╕в">}
	\intnote{run levels}, при цьому одно- та багато- користувацьк╕ режими
	розглядаються як два окремих робочих р╕вн╕. Кр╕м цього можуть
	бути також ╕нш╕, як, наприклад, р╕вень, в якому запуска╓ться X
	на системн╕й консол╕\intnote{runlevel 5 в б╕льшост╕ систем}.

\index{робочий р╕вень}
\index{однокористувацький режим}
\index{багатокористувацький режим}
\index{Система X Window}

	При звичайн╕й робот╕ \cmd{init} забезпечу╓ роботу \cmd{getty},
	як╕ дозволяють користувачам заре╓струватися в систем╕ та
	"<всиновлю╓"> процеси-сироти (т╕ процеси, батьки яких, тобто
	т╕ процеси в╕д яких вони породилися, вже померли
	(завершилися); в Юн╕кс╕ \emph{вс╕} процеси \emph{повинн╕} бути
	в ╓диному дерев╕, тобто вс╕х сирот потр╕бно всиновити.)

	П╕д час вимкнення системи, це саме \cmd{init} займа╓ться тим, що
	вбива╓ вс╕ ╕нш╕ процеси, в╕дмонтову╓ вс╕ файлов╕ системи та
	зупиня╓ процесор. ╤ \cmd{init} робить все це паралельно з ус╕ма
	╕ншими функц╕ями, на як╕ ще окр╕м цього в╕н був сконф╕╜урований.

\index{вбивання процес╕в}
\index{в╕дмонтовування файлових систем}
\index{зупинка процесора}

\subsection{Ре╓страц╕я з терм╕нал╕в (login)}

	Ре╓страц╕я в систем╕ з терм╕нал╕в (через л╕н╕ю посл╕довного
	зв'язку) та з системно╖ консол╕ (якщо X не працю╓ в даний
	момент) забезпечу╓ться програмою \cmd{getty}. Для кожного
	терм╕налу, з якого вх╕д в систему дозволений, \cmd{init}
	старту╓ окремий прим╕рник програми \cmd{getty}.  \cmd{getty}
	чита╓ ╕м'я користувача з клав╕атури ╕ запуска╓ програму
	\cmd{login}, яка чита╓ пароль. Якщо пароль ╕ ╕м'я користувача
	в╕рн╕, програма \cmd{login} запуска╓ командну оболонку
	(shell). Коли командна оболонка припиня╓ свою роботу (тобто
	користувач виходить з системи) або коли робота \cmd{login}
	перерива╓ться через те, що введений пароль ╕ ╕м'я користувача
	не в╕дпов╕дають один одному, \cmd{init} пом╕ча╓ це ╕ запуска╓
	новий прим╕рник \cmd{getty}. Ядро не ма╓ н╕якого в╕дношення до
	процес╕в ре╓страц╕╖ в систем╕ (╕ нав╕ть не пом╕ча╓ ╖х), це все
	забезпечу╓ться системними програмами.

\index{/sbin/getty}
\index{ре╓страц╕я в систем╕}
\index{вих╕д з системи}
\index{перев╕рка паролю}

\subsection{Syslog}

	Ядро та багато ╕нших системних програм продукують пов╕домлення
	про помилки, попередження та ╕нш╕ важлив╕
	пов╕домлення. Важливим ╓ те, щоб малася можлив╕сть п╕зн╕ше
	(дуже часто набагато п╕зн╕ше) переглянути вс╕ ц╕ пов╕домлення,
	тобто вони повинн╕ записуватися в файл. Програма, яка це
	робить - \cmd{syslog}. ╥╖ можна сконф╕╜урувати так, щоб вона
	сортувала пов╕домлення в р╕зн╕ файли в╕дпов╕дно того, або хто
	пише пов╕домлення або в╕д ступен╕ важливост╕ самого
	пов╕домлення. Наприклад, через те, що пов╕домлення в╕д ядра
	дуже часто важлив╕ш╕ в╕д ╕нших пов╕домлень ╕ ╖х треба
	регулярно перечитувати щоб передбачити виникнення проблем,
	пов╕домлення в╕д ядра дуже часто в╕дправляються в окремий
	файл.
	
\index{пов╕домлення про помилки}
\index{попередження}
\index{ло╜-файли (файли пов╕домлень)}

\subsection{Пер╕одичне виконання команд: \cmd{cron} та \cmd{at}}

	Як користувач╕, так ╕ системн╕ адм╕н╕стратори часто мають
	необх╕дн╕сть виконувати певн╕ команди пер╕одично. Наприклад,
	системному адм╕н╕стратору може знадобитись пер╕одично старати
	файли в директор╕ях, що служать для тимчасового збер╕гання
	файл╕в (\fn{/tmp} та \fn{/var/tmp}) в╕д старих файл╕в, щоб
	утримувати в╕д забивання диски (не вс╕ програми прибирають
	п╕сля себе так, як потр╕бно).

\index{пер╕одичне виконання команд|див. {cron та at}}
\index{тимчасов╕ файли}
\index{стирання тимчасових файл╕в}

	Для цього призначений серв╕с \cmd{cron}. Кожен користувач ма╓
	власний \cmd{crontab}, де в╕н перечисля╓ т╕ команди, як╕ в╕н
	хоче виконати та час коли, ц╕ команди мають
	виконуватися. Демон \cmd{cron} запуска╓ команди тод╕, коли
	потр╕бно. 

\index{демони!cron|див. {cron}}

	Серв╕с \cmd{at} под╕бний до \cmd{cron}, але в╕н викону╓
	команду т╕льки один раз: команда викону╓ться в заданий час,
	але не повторю╓ться.

\index{демони!at|див.{at}}

\subsection{Граф╕чний ╕нтерфейс}

	Н╕ Юн╕кс н╕ Л╕накс не включають ╕нтерфейс з користувачем в
	ядро. Зам╕сть цього вони надають можлив╕сть реал╕зувати його
	на р╕вн╕ програм користувача. Це в╕дноситься, як до текстового
	режиму роботи, так ╕ до граф╕чного. 

	Така побудова робить систему б╕льш гнучкою, ╕ впровадження
	нового ╕нтерфейс з користувачем ста╓ дуже легким. Але це також
	╓ ╕ певним недол╕ком. Через те, що ╕нтерфейс╕в створю╓ться
	досить багато, система ╓ б╕льш складною для вивчення.

	Граф╕чне середовище, що найчаст╕ше використову╓ться з
	Л╕наксом, носить назву X Windows (або просто X). X також не
	впроваджу╓ ╕нтерфейсу з користувачем, як такого. Воно т╕льки
	реал╕зу╓ в╕конну систему, тобто т╕ засоби, за допомогою яких
	можна реал╕зувати граф╕чний ╕нтерфейс. Серед найб╕льш
	популярних стил╕в граф╕чного ╕нтерфейсу використовуються так╕
	тро╓, як Athena, Motif та Open Look \begin{intnote}Останн╕м часом
	граф╕чн╕ ╕нтерфейси з'являються, як гриби п╕сля дощу. Досить
	назвати так╕, як \fn{Qt}, \fn{GTK} та \fn{GTK+}, \fn{JX},
	тощо. Розвиток в Л╕накс╕ п╕шов зараз ╕ншим шляхом, в╕д того,
	що був нав╕ть один-два роки тому (це пишеться в кв╕тн╕ 1999
	року). Цей розвиток в╕дм╕ня╓ нав╕ть те, що сказано в
	попередньому абзац╕ - тепер часто нема╓ необх╕дност╕ вивчати
	новий ╕нтерфейс. Можна просто настро╖ти необх╕дну оболонку
	так, щоб вона реал╕зувала знайомий граф╕чний ╕нтерфейс. Так,
	наприклад \fn{KDE}, яка базу╓ться на \fn{Qt}, може
	перемикатися в режими, як╕ ╕м╕тують так╕ досить в╕дм╕нн╕ м╕ж
	собою ╕нтерфейси, як \fn{Macintosh} та \fn{Windows}\end{intnote}.

\index{граф╕чний ╕нтерфейс}
\index{Система X Window}
\index{Athena}
\index{Motif}
\index{Open Look}

\subsection{Мережа}

	Мережа - це зас╕б за допомогою якого два або б╕льше
	комп'ютер╕в з'╓днуються таким чином, що вони можуть вести
	обм╕н даними один з одним. Реальн╕ методи, за допомогою яких
	в╕дбува╓ться таке сполучення,досить складн╕, але к╕нцевий
	результат того вартий.

	Операц╕йн╕ системи Юн╕кс багат╕ на ресурси для роботи в
	мережах. Найб╕льш фундаментальн╕ послуги (файлов╕ системи,
	друк, збереження ╕нформац╕╖, тощо) можуть зд╕йснюватися при
	сполученн╕ р╕зних комп'ютер╕в в мережу. Це робить системну
	адм╕н╕страц╕ю набагато прост╕шою, бо дозволя╓ централ╕зовану
	адм╕н╕страц╕ю. Тим не менше, вс╕ переваги м╕крокомп'ютер╕в та
	розпод╕лено╖ обчислювально╖ техн╕ки (так╕, як знижена варт╕сть
	та висока витривал╕сть) залишаються присутн╕ми.

\index{цетрал╕зован╕ обчислення}
\index{розпод╕лена обчислювальна техн╕ка}
\index{ст╕йк╕сть проти помилок}

	Однак, цей п╕дручник дуже мало торка╓ться питань адм╕н╕страц╕╖
	комп'ютерних мереж. Зверн╕ться до Пос╕бника адм╕н╕стратора
	мереж╕ за б╕льш детальним описом цих питань (починаючи з основ
	роботи комп'ютерних мереж).

\subsection{Ре╓страц╕я в систем╕ при робот╕ в мереж╕}

	При робот╕ в систим╕ через л╕н╕ю посл╕довного зв'язку, для
	кожного окремого терм╕налу ╕сну╓ своя вид╕лена л╕н╕я
	посл╕довного зв'язку. Робота в систем╕ вигляда╓ ╕накше, коли
	комп'ютер п╕дключений до мереж╕\intnote{Нав╕ть, якщо комп'ютер
	ф╕зично не п╕дключений до мереж╕, але Ви працю╓те в
	\texttt{X}, ситуац╕я вигляда╓ зовс╕м ╕накше, оск╕льки
	\texttt{X} ╓ \emph{ сутт╓во} ор╕╓нтованою на роботу в мереж╕ ╕
	розгляда╓ будь-який комп'ютер, як працюючий в мереж╕.}.  Для
	кожно╖ особи, що з'╓дну╓ться з даним комп'ютером, ╕сну╓
	окремий в╕ртуальний зв'язок ╕ може ╕снувати дов╕льна к╕льк╕сть
	з'╓днань\footnote{Або, принаймн╕, дуже багато. Все ще
	пропускна зд╕бн╕сть мереж╕ залиша╓ться обмеженим ресурсом, ╕
	через це все-ще ╕сну╓ верхня межа к╕лькост╕ одночасно
	дозволених робочих сес╕й при використанн╕ зв'язку через
	мережу.}. Через це для кожно╖ ново╖ робочо╖ сес╕╖ (тобто для
	кожного нового в╕ртуального зв'язку) неможливо запускати
	окремий \cmd{getty} .  Кр╕м того, ╕сну╓ к╕лька в╕дм╕нних
	метод╕в ре╓страц╕╖ в систем╕ при робот╕ в мережах TCP/IP -
	\cmd{telnet} та \cmd{rlogin} ╓ основними з них.

	Зам╕сть ф╕ксованих \cmd{getty}'╕в при ре╓страц╕╖ через мережу,
	за процес ре╓страц╕╖ в╕дпов╕да╓ один демон на кожен тип
	з'╓днання (тобто \cmd{telnet} та \cmd{rlogin} мають кожен
	свого демона ) ╕ цей демон прислуха╓ться до вс╕х спроб вв╕йти в
	систему. Коли в╕н чу╓, що хтось п╕дключа╓ться до системи, в╕н
	породжу╓ нову коп╕ю самого себе, щоб ця коп╕я обслуговувала
	саме цю конкретну спробу з'╓днання. В цей час перший демон
	продовжу╓ слухати, чи не з'являться ╕нш╕ спроби п╕дключитися
	до системи. Новостворена коп╕я демона працю╓ под╕бно до
	\cmd{getty}.

\index{демони!telnet|див.{telnet}}
\index{демони!rlogin|див.{rlogin}}

\subsection{Файлова система мереж╕ (Network file systems, NFS)}
\label{sec:NFS}

	Одна з найкорисн╕ших справ, що ╖х може допомогти реал╕зувати
	комп'ютерна мережа, це сп╕льне використання файл╕в за
	допомогою \defin{файлово╖ системи мереж╕}. Система, яка
	використову╓ться найширше, була розроблена ф╕рмою Sun ╕ носить
	назву Network File System або NFS.

\index{NFS}
\index{файлова система мереж╕!network file systems}
\index{Network File System|див.{NFS}}

	При робот╕ з NFS будь-як╕ файлов╕ операц╕╖, що виконуються
	програмою на одному з комп'ютер╕в, передаються по мереж╕ ╕нш╕й
	машин╕. При цьому програма дума╓, що вс╕ файли, як╕ фактично
	знаходяться на ╕ншому комп'ютер╕, розташован╕ в локальн╕й
	файлов╕й систем╕, на цьому комп'ютер╕, на якому працю╓ дана
	програма. Такий п╕дх╕д робить обм╕н та сп╕льне використання
	╕нформац╕╖ надзвичайно простим, оск╕льки не вимага╓ ╕
	найменшо╖ модиф╕кац╕╖ програм.

\subsection{Пошта}

	Електронна пошта як звичайно ╓ найважлив╕шим засобом
	сп╕лкування за допомогою комп'ютера. Електронний лист
	збер╕га╓ться у файл╕ в спец╕альному формат╕, ╕ для читання та
	передач╕ кореспонденц╕╖ використовуються призначен╕ для цього
	програми.
	
\index{зв'язок}
\index{e-mail|див.{електронна пошта}}
\index{пошта, електронна|див.{електронна пошта}}
\index{електронна пошта}
\index{лист|див.{електронна пошта}}

	Кожен користувач ма╓ \defin{вх╕дну поштову скриню} (файл
	спец╕ального формату), в як╕й збер╕гаються вс╕ нов╕
	листи. Коли хто-небудь в╕дсила╓ листа, поштова програма
	в╕дшукову╓ поштову скриню адресату ╕ допису╓ листа в к╕нець
	поштово╖ скрин╕. Якщо поштова скриня знаходиться на ╕нш╕й
	машин╕, лист в╕дсила╓ться на цю машину, ╕ ця (в╕ддалена)
	машина доставля╓ листа до поштово╖ скрин╕ адресата, тим чином,
	який вона вважа╓ за найкращий.

\index{поштова скриня}
\index{вх╕дна поштова скриня}

	Система електронно╖ пошти склада╓ться з багатьох
	програм. Доставка пошти до м╕сцево╖ чи в╕ддалено╖ скрин╕
	викону╓ться одн╕╓ю програмою (\defin{агентом доставки пошти}
	(mail transfer agent, MTA): наприклад, \cmd{sendmail} або
	\cmd{smail}), в той час як програм, якими користуються
	безпосередньо користувач╕, багато ╕ вони значно в╕др╕зняються
	одна в╕д одно╖ (\defin{агент користувача пошти} (mail user
	agent, MUA): наприклад, \cmd{pine}, \cmd{elm}). Поштов╕ скрин╕
	звичайно знаходяться в  \fn{/var/spool/mail}.


\subsection{Друк}

	Кожного певного в╕дтинку часу т╕льки одна особа може
	користуватися принтером. Але не розпод╕ляти послуги принтера
	м╕ж користувачами ╓ надзвичайно неекономним. Через це принтери
	керуються програмами, як╕ вт╕люють \defin{чергу друкування}
	\intnote{print spool, print queue}: вс╕ роботи для друку
	ставляться в чергу, ╕ коли друкування одного документу
	зак╕нчу╓ться, автоматично почина╓ться друк ╕ншого. Це зв╕льню╓
	користувач╕в в╕д орган╕зовування черги "<на принтер"> та
	боротьби за контроль над принтером. \footnote{ Зам╕сть цього
	вони формують чергу \emph{б╕ля} принтера, чекаючи на
	в╕ддрукован╕ матер╕али, через те, що, мабуть, н╕хто ╕ н╕коли
	не буде здатний змусити програмне забезпечення в╕дпов╕сти на
	запитання: коли саме буде в╕ддруковане те чи ╕нше конкретне
	завдання з черги. Цей невеличкий факт ╓ надзвичайним руш╕╓м
	вза╓мов╕дносин в колектив╕.}

\index{черга принтера}
\index{сп╕льне користування принтером}
\index{вза╓мов╕дносини}

	Програмне забезпечення черги принтера \defin{скида╓} (spool)
	матер╕али призначен╕ для друку на диск, тобто, до того часу,
	поки робота перебува╓ в черз╕, текст збер╕га╓ться в файл╕. Це
	да╓ змогу прикладн╕й програм╕ швидко "<випльовувати"> роботи
	на друк. Прикладна програма не ма╓ чекати на те, щоб дана
	робота була фактично в╕ддрукована, перш, н╕ж продовжувати
	роботу. Це дуже зручно, бо дозволя╓, наприклад, в╕ддрукувати
	одну верс╕ю документу, ╕, не чекаючи на результати друку,
	приступити до редагування наступно╖ верс╕╖.
\index{spooling}

\section{Побудова файлово╖ системи}

	Файлова система склада╓ться з багатьох частин; до файлово╖
	системи root входять \fn{/bin}, \fn{/lib}, \fn{/etc},
	\fn{/dev} та к╕лька ╕нших. ╢ окрема файлова система \fn{usr}
	для програм та даних, що не зм╕ннюються з часом. ╢ файлова
	система \fn{var}, яка м╕стить так╕ дан╕, що зм╕нюються, як,
	наприклад, (файли ре╓страц╕╖ пов╕домлень - log file). Також ╓
	файлова система \fn{home}, де м╕стяться файли, що належать
	персонально користувачам системи. В залежност╕ в╕д
	конф╕╜урац╕╖ апаратного забезпечення та вол╕ системного
	адм╕н╕стратора файлов╕ системи можуть в╕др╕знятися в╕д того,
	що тут написано, може нав╕ть трапитися, що все разом буде
	знаходитися на одному дисковому розд╕л╕.


	Розд╕л~\ref{chap:walkabout} опису╓ побудову файлово╖ системи в
	подробицях; "<Стандарт файлово╖ системи Л╕накс"> да╓ опис з
	╕ще б╕льшими подробицями.
\index{FSSTND}
\index{Стандарт файлово╖ системи Л╕накс|див.{FSSTND}}
\index{Стандарт файлово╖ системи |див.{FSSTND}}
