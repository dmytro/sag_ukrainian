%--------------------------------------------------------------------
%\chapter[Ре╓страц╕я та вих╕д]{Ре╓страц╕я в систем╕ та вих╕д з системи}
\chapter{Ре╓страц╕я в систем╕ та вих╕д з системи}
\label{ch:logins}
%--------------------------------------------------------------------
% $Id: logins.tex,v 1.1.1.2 2004-03-22 12:59:26 dmytro Exp $

        \begin{verse}\it
        This chapter needs a quote.  Suggestions, anyone?  \\
        \rm\end{verse}

        \noindent
	Цей розд╕л опису╓ те, що в╕дбува╓ться при ре╓страц╕╖
	користувача в систем╕ та виход╕ з не╖. В деталях описана також
	деяка вза╓мод╕я фонових процес╕в, файл╕в
	ре╓страц╕╖\intnote{log files} та файл╕в конф╕╜урац╕╖.

\section{Ре╓страц╕я в систем╕ через терм╕нали}

	На рис.~\ref{fig:terminal-logins} показано, що саме
	в╕дбува╓ться при ре╓страц╕╖ користувач╕в з терм╕налу. Перш
	за все \cmd{init} перев╕ря╓, чи ╓ програма \cmd{getty} для
	з'╓днання з терм╕налом (чи консоллю). \cmd{getty} сидить на
	терм╕нал╕ ╕ слуха╓, чека╓ поки користувач пов╕домить про те,
	що в╕н готовий для ре╓страц╕╖ в систем╕ (зм╕ст ц╕╓╖ фрази
	просто означа╓, що користувач повинен надрукувати
	що-небудь). Коли \cmd{getty} пом╕тить, що користувач вв╕в щось
	з клав╕атури, в╕н виводить на екран прив╕тання з файлу
	\fn{/etc/issue}, просить користувача ввести ╕м'я ╕ врешт╕-решт
	запуска╓ програму \cmd{login}.  \cmd{login}'у переда╓ться
	параметром ╕м'я користувача ╕ в╕н, в свою чергу, попросить
	користувача ввести пароль для входу в систему. Якщо ╕м'я ╕
	пароль в╕дпов╕дають один одному, \cmd{login} переда╓
	управл╕ння командн╕й оболонц╕, яка вказана для користувача в
	\fn{/etc/passwd}, якщо ж н╕ - просто зак╕нчу╓ свою роботу
	(можливо давши користувачев╕ ще один шанс спробувати з
	паролем). П╕сля цього \cmd{init} пом╕ча╓, що терм╕нал
	зв╕льнився ╕ старту╓ новий \cmd{getty} на цьому терм╕нал╕.

\begin{figure}[htb]
\begin{center}
\includegraphics{logins/logins-via-terminals.ps}
\end{center}
\caption{Вх╕д в систему через терм╕нал: вза╓мод╕я  \cmd{init}, \cmd{getty},
	\cmd{login} та командно╖ оболонки.}
\label{fig:terminal-logins}
\end{figure}

	В╕дм╕тимо, що ╓диний новий процес при цьому - це той, який
	створений \cmd{init}'ом (за допомогою системно╖ функц╕╖
	\cmd{fork}), а \cmd{getty} та \cmd{login} т╕льки зам╕нюють
	програму, що працювала до них (за допомогою системно╖ функц╕╖
	\cmd{ecxec}).

	Для того, щоб пом╕тити вх╕д користувача в систему потр╕бна
	окрема програма на кожному посл╕довному порт╕, оск╕льки
	пом╕тити активн╕сть на посл╕довн╕й л╕н╕╖ може бути досить
	складно. Кр╕м того, швидк╕сть передач╕ та ╕нш╕ параметри, як╕
	дуже важлив╕ для телефонних л╕н╕й, можуть зм╕нюватися в╕д
	дзв╕нка до дзв╕нка, ╕ тому \cmd{getty} пристосову╓ться до
	властивостей посл╕довного порта.

	╤сну╓ к╕лька верс╕й \cmd{getty} та \cmd{init}, кожна з яких
	ма╓ як сво╖ позитивн╕, так ╕ негативн╕ якост╕.  Д╕знатйтеся
	про верс╕╖, встановлен╕ саме в Ваш╕й систем╕, але корисно
	знати також ╕ про ╕нш╕ верс╕╖ (можна скористуватися мапою
	програмного забезпечення Л╕накса для пошуку потр╕бних
	програм). Якщо Ви не користу╓тесь телефонними каналами чи
	посл╕довними л╕н╕ями зв'язку для п╕д'╓днання до ╕нших систем
	чи ╤нтернету, то скор╕ше всього Вам нема про що турбуватися в
	в╕дношенн╕ \cmd{getty}, але про \cmd{init} все-таки корисно
	дещо знати.

\section{Ре╓страц╕я в систем╕ через мережу}

	Два комп'ютера в мереж╕, як звично, зв'язан╕ одним ф╕зичним
	кабелем. Коли вони сп╕лкуються через мережу, програми, як╕
	приймають участь в сп╕лкуванн╕, з'╓днан╕ через
	\defin{в╕ртуальне з'╓днання}, яке можна можна вважати уявним
	кабелем. Поки програми знаходяться на обох к╕нцях з'╓днання,
	вони тримають монопол╕ю на кабель. Однак, оск╕льки кабель
	всього-навсього уявний, а не справжн╕й, то операц╕йна система
	може мати насправд╕ к╕лька уявних з'╓днань при одному
	ф╕зичному. Таким чином, маючи всього-навсього один кабель,
	к╕лька програм можуть сп╕лкуватися, нав╕ть не п╕дозрюючи про
	╕нш╕ з'╓днання. Можливо нав╕ть при╓днати к╕лька комп'ютер╕в до
	одного ╕ того-ж кабеля. Кожне в╕ртуальне з'╓днання
	встановлю╓ться м╕ж двома комп'ютерами, але ╕нш╕ в цей час
	можуть не звертати уваги на ╕снуюче з'╓днання, оск╕льки вони
	не приймають в ньому участ╕.

	Це - складне, але при тому ж занадто абстраговане в╕дображення
	д╕йсност╕. Однак, його достатньо для того, щоб зрозум╕ти, чому
	ре╓страц╕я в систем╕ через мережу трохи в╕др╕зня╓ться в╕д
	ре╓страц╕╖ з терм╕налу. Уявне з'╓днання встановлю╓ться тод╕,
	коли на двох комп'ютерах ╓ програми, як╕ бажають встановити
	зв'язок. Оск╕льки в принцип╕ можливо заре╓струватися з
	будь-якого комп'ютера в мереж╕ на будь-якому ╕ншому, ╕сну╓
	надзвичайна к╕льк╕сть потенц╕йних уявних з'╓днань. Через це
	непрактично стартувати \cmd{getty} для кожного
	потенц╕йного користувача (тобто для кожно╖ спроби ре╓страц╕╖).

	╤сну╓ ╓диний процес inetd (анало╜╕чний до \cmd{getty}, який
	займа╓ться \emph{ вс╕ма} з'╓днаннями в мереж╕. Коли в╕н
	пом╕ча╓ вх╕дний запит про ре╓страц╕ю в мереж╕ (тобто, в╕н
	пом╕ча╓, що якийсь процес ╕ззовн╕ просить про зв'язок з
	процесом на даному комп'ютер╕), \cmd{initd} старту╓ новий
	процес, який буде займатися цим одним ╓диним
	запитом. Ори╜╕нальний процес залиша╓ться живим ╕ продовжу╓
	слухати, чекаючи нових запит╕в на ре╓страц╕ю.

	Щоб життя не здавалося малиною, ╕сну╓ к╕лька комун╕кац╕йних
	протокол╕в для ре╓страц╕╖ в мереж╕. Два найб╕льш важливих з
	них - це \cmd{telnet} та \cmd{rloign}. Додатково до ре╓страц╕╖
	ще ╓ багато ╕нших тип╕в умовних з'╓днань (для FTP, Gopher,
	HTTP та для багатьох ╕нших серв╕с╕в мереж╕). Неефективно мати
	по одному процесу на кожен тип з'╓днання, як╕ т╕льки слухають
	╕ чекають. Тож зам╕сть цього вжива╓ться всього один
	"<слухач">, який вм╕╓ розп╕знавати тип з'╓днання ╕ запускати
	в╕дпов╕дну програму, яка буде забезпечувати потр╕бний
	серв╕с. Цей "<слухач"> назива╓ться \cmd{inetd}. Б╕льш повну
	╕нформац╕ю про нього можна отримати з "<Пос╕бника по системн╕й
	адм╕н╕страц╕╖ мереж╕ Л╕накса">.
	
\section{Що робить  \cmd{login}}

	Програма \cmd{login} займа╓ться перев╕ркою користувача,
	впевнюючись, що ╕м'я користувача та його пароль в╕дпов╕дають
	один одному. П╕сля цього вона встановлю╓ в╕дпов╕дне середовище
	для даного користувача, встановлюючи в╕дпов╕дн╕ дозволи на
	посл╕довну л╕н╕ю зв'язку та старту╓ командну оболонку для
	користувача. 

	П╕д час початково╖ установки \cmd{login} також виводить на
	екран невеличкий файл \fn{/etc/motd} (коротенька фраза
	дня\intnote{message of the day}) ╕ перев╕ря╓ електронну
	пошту. Ц╕ функц╕╖ можна заборонити створивши файл
	\cmd{.hushlogin} в домашн╕й директор╕╖ користувача.

	Якщо ╕сну╓ файл \fn{/etc/nologin}, то ре╓страц╕я в систем╕
	заборонена. Звичайно такий файл створю╓ться командами типу
	\cmd{shutdown}. \cmd{login} перев╕ря╓ ╕снування такого файлу,
	╕ якщо в╕н ╕сну╓, в╕н в╕дмовля╓ в ре╓страц╕╖ користувачев╕,
	але перш, н╕ж зак╕нчити роботу, виводить зм╕ст цього файлу на
	екран. 

	\cmd{login} запису╓ (через \cmd{syslog}) вс╕ спроби ре╓страц╕╖
	в систем╕, як╕ не вдалися, в╕н також запису╓ \emph{ вс╕}
	ре╓страц╕╖ в систем╕ користувача \texttt{root}. Обидва типи
	запис╕в можуть використовуватися для в╕дсл╕дковування спроб
	вторгнень в систему.

	Вс╕ користувач╕, на даний момент заре╓строван╕ в систем╕,
	записан╕ в файл╕ \cmd{/var/run/utmp}. Цей файл д╕йсний т╕льки
	до тих п╕р, поки система не перевантажу╓ться або
	вимика╓ться. В╕н перечислю╓ вс╕х користувач╕в разом з
	терм╕налами (або з'╓днаннями), на яких вони заре╓строван╕,
	разом з деякою додатковою ╕нформац╕╓ю. Команди \cmd{who},
	\cmd{w} та ╕нш╕ звертаються до файлу \fn{utmp} за
	╕нформац╕╓ю. 

	Вс╕ усп╕шн╕ ре╓страц╕╖ в систем╕ записан╕ в
	\fn{/var/log/wtmp}. Цей файл може рости безмежно, отже його
	варто чистити пер╕одично, встановивши, наприклад, щотижневий
	cron для цього.\intnote{Багато як╕ з Л╕накс╕в роблять
	це з самого початку автоматично}. Переглядати файл \fn{wtmp}
	можна за допомогою команди \cmd{last}. 

	Обидва файли - як \fn{utmp}, так ╕ \fn{wtmp} - записан╕ в
	дв╕йковому формат╕ (див. п╕дказку по \man{utmp}), ╕, на жаль,
	╖х дуже незручно анал╕зувати без використання спец╕альних
	команд. 

\section{X та xdm}

%	\meta X implements logins via xdm; also: xterm -ls

\section{Керування доступом}

	Традиц╕йно база даних користувач╕в в Юн╕кс╕ записувалася в
	файл╕ \fn{/etc/passwd}. Деяк╕ системи користуються
	\defin{т╕ньовими паролями}\intnote{shadow passwords}. В таких
	системах парол╕ користувач╕в записан╕ в файл╕
	\cmd{/etc/shadow}. \begin{intnote}Не завжди. SunOS запису╓ т╕ньов╕
	парол╕ в \fn{/etc/security/passwd.adjunct.}\end{intnote} Орган╕зац╕╖ з
	великими комп'ютерними мережами користуються NIS для
	розпод╕леного збер╕гання ╕нформац╕╖ про користувач╕в. Кр╕м
	того, можна встановити автоматичне поширення ╕нформац╕╖ до
	вс╕х комп'ютер╕в в мереж╕ з одного центрального сервера.
	
	База даних користувач╕в м╕стить в соб╕ не т╕льки ╕нформац╕ю
	про парол╕, а також деяку додаткову ╕нформац╕ю про
	користувач╕в, таку як ╖хн╕ ╕мена, домашн╕ директор╕╖ та
	командн╕ оболонки. Ця (╕нша) ╕нформац╕я повинна бути загально
	доступною, так, щоб кожен м╕г ╖╖ прочитати. Отже, парол╕ треба
	збер╕гати в закодованому вигляд╕. При цьому ╓ один сутт╓вий
	м╕нус - будь-хто може читати закодован╕ парол╕ ╕ озбро╖вшись
	криптограф╕чними методами, може ╖х розкодувати. Т╕ньов╕ парол╕
	намагаються запоб╕гти цьому. В системах з т╕ньовими паролями
	парол╕ записуються окремо в╕д ╕нших даних про користувач╕в, в
	файл╕ в╕дкритому на читання т╕льки \texttt{root} (парол╕ все
	ще залишаються закодованими). Однак, встановлення т╕ньових
	парол╕в вже п╕сля встановлення системи може бути
	проблематичним.

	З т╕ньовими паролями чи без них, завжди варто бути певним, що
	вс╕ парол╕ в систем╕ над╕йн╕, тобто, що ╖х не легко
	вгадати. Для злому парол╕в може використовуватися програма
	\cmd{crack}. Будь-який пароль вгаданий ц╕╓ю програмою
	вважа╓ться ненад╕йним. Програму \cmd{crack} можуть
	використовувати також ╕ т╕, хто намага╓ться зломати парол╕,
	але нею варто користуватися ╕ системному адм╕н╕стратору для
	того, щоб перев╕ряти ст╕йк╕сть парол╕в. До вживання добрих
	парол╕в може змусисти також програма \cmd{passwd}. Це трохи
	ефективн╕ше в терм╕нах процесорного часу, оск╕льки зломка
	парол╕в вимага╓ досить таки ╕нтенсивно╖ роботи прооцесора.

	База даних груп користувач╕в збер╕га╓ться в файл╕
	\fn{/etc/group}. В системах з т╕ньовими паролями може ╕снувати
	також файл \fn{/etc/shadow.group}. 

	Як правило \texttt{root} не може заре╓струватися в систем╕ з
	в╕ддаленого терм╕налу або з мереж╕. Це дозволя╓ться т╕льки на
	терм╕налах, перел╕чених в файл╕ \cmd{/etc/securetty}.
	%
%	\begin{intnote} \texttt{/etc/default/login} в Solaris\end{intnote}  
	%
	Для цього треба
	мати ф╕зичний доступ до одного ╕з цих терм╕нал╕в. Однак можна
	заре╓струватися в систем╕ п╕д ╕менем ╕ншого користувача з
	будь-якого терм╕налу. П╕сля цього, щоб стати \texttt{root}'ом
	треба виконати команду \cmd{su}.


\section{Старт командно╖ оболонки}

	Коли почина╓ працювати ╕нтерактивна командна оболонка, вона
	автоматично приводить в д╕ю к╕лька попередньо визначених
	файл╕в. Р╕зн╕ оболонки використовують р╕зн╕ стартов╕ файли п╕д
	час свого старту. Проконсультуйтесь з документац╕╓ю сво╓╖
	оболонки, щоб визначити як╕ саме файли використовуються в
	Вашому випадку.

	Б╕льш╕сть оболонок на початку виконують деякий глобальний
	файл, наприклад оболонка Б'йорна \fn{/bin/sh} викону╓ файл
	\fn{/etc/profile}. Пот╕м викону╓ться файл \fn{.profile} з
	домашньо╖ директор╕╖ користувача. Файл \cmd{/etc/profile} да╓
	можлив╕сть системному адм╕н╕стратору встановити загальн╕ для
	вс╕х користувач╕в системи властивост╕, так╕, наприклад, як
	╓дина дор╕жка для пошуку файл╕в для виконання PATH, особливо,
	якщо потр╕бно встановити як╕сь спец╕альн╕ маршрути пошуку
	файл╕в в систем╕ додатково до стандартних. З ╕ншого боку
	\fn{.profile} дозволя╓ зм╕нювати параметри свого середовища
	кожному окремому користувачев╕, ╕ якщо це необх╕дно, в╕дм╕няти
	загальносистемн╕ установки.
