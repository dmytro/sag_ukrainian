%--------------------------------------------------------------------
%\chapter[Нос╕╖ ╕нформац╕╖]{Використання диск╕в та ╕нших нос╕╖в ╕нформац╕╖}
\chapter{Використання диск╕в та ╕нших нос╕╖в ╕нформац╕╖}
%--------------------------------------------------------------------

        \begin{verse}\it
	На пустому диску можна шукати до неск╕нченост╕.\\
        \rm\end{verse}

% the following metas need too much work for the next version
%
%	\meta copying a directory/disk verbatim
%
%	\meta disaster recovery: program to scan for ext2 superblocks
%
%	\meta explain lost+found; how to fix a filesystem; what to do when
%	there is a bad block; identifying the file that has the bad block
%	
%	\meta chart that shows characteristics of various fs: max size,
%	max file size, usable as root, max name length, speed, support
%
%	\meta 
%	Recovering from a bad MBR or super block.
%	Manually remounting (ro->rw, rw->ro, when, why)
%	automounting
%	MD patches
%	Why does Linux read/write disk in background?
%	how to mount a dos disk so that everyone can access it?
%	supermount
%	ide disks map away bad sectors (until they're too many, then
%	use badblocks)
%	mounting: mountee root becomes mount point, e.g. permissions/ownership
%	linux has maximum of 15 partitions (not inherent in partition
%		scheme!)
%	max ext2 part size is 2TB, file 2 GB
%	ext2 fragmentation
%	list important device files for disks et al as a table

        \noindent
	При установц╕ чи поновленн╕ системи Вам доводиться виконувати
	досить багато ман╕пуляц╕й з Вашими дисками. На них потр╕бно
	створити файлов╕ системи таким чином, щоб можна було збер╕гати
	потр╕бн╕ файли ╕ залишити необх╕дний прост╕р для р╕зноман╕тних
	частин системи. 

	Цей розд╕л поясню╓ вс╕ ц╕ початков╕ д╕╖. В б╕льшост╕ випадк╕в
	п╕сля того, як Ваша система встановлена ╕ обладнана, Вам не
	потр╕бно проходити через вс╕ т╕ ж сам╕ етапи знову, кр╕м х╕ба
	що, як при використанн╕ гнучких диск╕в. Але Вам потр╕бно буде
	повернутися до цього розд╕лу, якщо Ви дода╓те нов╕ диски до
	системи, чи хочете точн╕ше керувати використанням дискового
	простору.

	Основн╕ задач╕ при адм╕н╕струванн╕ диск╕в так╕:
	%%
        \begin{itemize}
        \item

	Форматування диску. Щоб п╕дготувати диск до роботи, на цьому
	етап╕ виконуються р╕зноман╕тн╕ кроки, так╕, як наприклад,
	перев╕рка дефектних блок╕в диску. (В даний час для б╕льшост╕
	диск╕в форматування не потр╕бно.)

        \item

	Розбиття диску на розд╕ли. Диск потр╕бно розд╕ляти на окрем╕
	п╕дрозд╕ли в тому випадку, коли необх╕дно вид╕лити прост╕р для
	р╕зних вид╕в д╕яльност╕, як╕ (види д╕яльност╕) не повинн╕
	заважати один одному. Одним з привод╕в для розд╕лу диску може
	бути бажання встановити к╕лька операц╕йних систем на одному
	диску. ╤ншим - бажання тримати на ╕ншому розд╕л╕ т╕ файли, що
	не в╕дносяться до загальносистемних, з метою полегшення
	резервування даних та щоб зберегти систему в╕д суц╕льного краху.

        \item

	Створення файлово╖ системи (потр╕бного типу) на кожному
	окремому з розд╕л╕в диску. Диск не означа╓ практично н╕чого
	для Л╕накса до того часу, поки на ньому не створена файлова
	система. \begin{intnote}кр╕м, х╕ба що своп-простору, який в багатьох
	Юн╕ксах не вимага╓ в╕д системного адм╕н╕стратора практично
	н╕яких д╕й. Юн╕кс може користуватися своп-простором зразу ж
	п╕сля того, як створений розд╕л диску. В Л╕накс╕ спочатку
	треба виконати компнду \cmd{mkswap}, яка створую╓ "<файлову
	систему">. Насправд╕ Л╕накс запису╓ в заголовку своп-розд╕лу
	т╕льки спец╕альний п╕дпис\intnote{signаture}, а користу╓ться
	все-таки "<сирим"> п╕дрозд╕лом.\end{intnote} П╕сля цього можна створювати
	файли та звертатись до них.

        \item 
	
	Монтування р╕зних файлових систем, щоб сформувати ╓дину
	структуру (або автоматично, або ж вручну, т╕льки тод╕, коли це
	необх╕дно. Вручну змонтован╕ файлов╕ системи у б╕льшост╕
	випадк╕в потр╕бно ╕ розмонтувувати також вручну.).

        \end{itemize}

	В розд╕л╕~\ref{chap:mem} м╕ститься ╕нформац╕я про в╕ртуальну
	пам'ять та дисковий кеш, про як╕ теж варто мати деяке поняття,
	при користуванн╕ дисками.

	Даний розд╕л поясню╓, що Вам потр╕бно знати про гнучк╕ та
        жорск╕ диски, CD-ROM та приводи магн╕тно╖ стр╕чки. 

\section{Два типи пристро╖в}

	Юн╕кс, а також ╕ Л╕накс, розр╕зняють два в╕дм╕нних м╕ж собою
	типи пристро╖в: блочн╕ пристро╖ з дов╕льним
	доступом\intnote{random access} (якими ╓ диски) та пристро╖ з
	посимвольним доступом\intnote{character devices} (прикладами
	яких ╓ магн╕тн╕ стр╕чки та посл╕довн╕ л╕н╕╖ зв'язку), деяк╕ з
	яких можуть бути з посл╕довним доступом, а ╕нш╕ - з
	дов╕льним. Кожен пристр╕й, який п╕дтриму╓ться системою,
	представлений в файлов╕й систем╕ \defin{спец╕альним файлом
	пристрою}. П╕д час читання чи запису в файл пристрою, дан╕
	приходять чи в╕дправляються до пристрою представленого
	спец╕альним файлом. Таким чином не потр╕бн╕ жодн╕ спец╕альн╕
	програми (або ж як╕сь спец╕альн╕ методоло╜╕╖ програмування,
	як, наприклад, перехват перепин╕в чи опитування посл╕довного
	порту) для того т╕льки, щоб звертатися до пристро╖в.
	Наприклад, для того, щоб просто в╕дправити файл на принтер,
	достатньо просто виконати

		%
		\begin{quote}\tt
\verb|$| {\sl cat filename $>$ /dev/lp1} \\ 
\verb|$|
		\rm\end{quote}
		%

	╕ зм╕ст файлу буде роздрукований на принтер╕ (звичайно ж файл
	повинен бути в формат╕ зрозум╕лому для принтера). Однак,
	зважаючи на те, що важко назвати гарною звичкою пересилання
	файлу прямо на принтер кожним окремим користувачем, люди
	звично користуються спец╕альною програмою для цього (в
	б╕льшост╕ систем \cmd{lpr}). Ця програма гаранту╓, що т╕льки
	один файл переда╓ться на принтер для друку в кожен момент часу
	╕ автоматично переда╓ на друк наступний, як т╕льки впора╓ться
	з друкуванням попереднього. Щось под╕бне потр╕бно також для
	б╕льшост╕ ╕нших пристро╖в в систем╕. Справд╕, користувач╕ не
	повинн╕ турбуватися про як╕сь там "<пристро╖"> практично н╕коли.

	Через те, що пристро╖ ╓ звичайними файлами в файлов╕й систем╕
	(в директор╕╖ \fn{/dev}, дуже легко просто подивитись як╕ з
	пристро╖в ╕снують за допомогою команди \cmd{ls} чи будь-яко╖
	╕ншо╖ п╕дходящо╖ команди. Перший стовпчик на екран╕ при
	виконанн╕ команди \cmd{ls -l} м╕стить тип файлу та дозволи на
	цей файл. Наприклад, дивлячись на спец╕альний файл
	посл╕довного порту на сво╖й систем╕ я бачу:
		%
		\begin{quote}\tt
\verb|$| {\sl ls -l /dev/cua0} \\
\verb|crw-rw-rw-   1 root     uucp       5,  64 Nov 30  1993 /dev/cua0| \\
\verb|$| 
		\rm\end{quote}
		%

	Перша л╕тера в першому стовчику, тобто `{\tt c}' в
	вищенаведеному приклад╕  в {\tt crw-rw-rw-} показу╓ доск╕пливому
	користувачев╕ тип файлу, тобто, в цьому випадку, символьний
	спец╕альний файл. Для звичайних файл╕в цей символ буде `{\tt
	-}', для директор╕й - `{\tt d}', а для блочних пристро╖в -
	`{\tt b}'. Детальна ╕нформац╕я подана з цього питання в
	стор╕нц╕ п╕дказки для \cmd{ls}.

	Завважте, що нав╕ть якщо пристро╖ не встановлен╕ на даному
	комп'ютер╕, файли спец╕альних пристро╖в ╕снують
	все-одно. Отже, те, що Ви ма╓те файл \fn{/dev/sda}, ще не
	св╕дчить про те, що Ви справд╕ ма╓те SCSI диск п╕дключений до
	системи. Збер╕гання вс╕х цих пристро╖в в систем╕ просто робить
	програми установки трохи прост╕шими ╕ в╕д цього ста╓ легшою
	установка нового обладнання (не потр╕бно в╕дшуковувати в╕рн╕
	параметри для апаратного пристрою та створювати спец╕альн╕
	файли для нього).

\section{Жорстк╕ диски}

	Даний п╕дрозд╕л ознайомить читача з терм╕ноло╜╕╓ю, що ма╓
	в╕дношення до жорстких диск╕в. Якщо Ви вже знайом╕ з терм╕нами
	та концепц╕ями, Ви можете пропустити його. 

	Рисунок~\ref{fig:hd-schematic} показу╓ схематичну д╕а╜раму
	найважлив╕ших частин жорсткого диску. Жорсткий диск
	склада╓ться з одн╕╓╖ або б╕льше циркулярних
	\defin{пластин}\footnote{Пластини виготовляються з твердо╖
	речовини, тако╖, як алюм╕н╕й, зв╕дки ╕ походить назва
	жорсткого диску} на яких одна або обидв╕ \defin{поверхн╕}
	покрит╕ магн╕тною речовиною, яка ╕ використову╓ться для запису
	даних. Для кожно╖ тако╖ поверхн╕ ╕сну╓ власна
	\defin{записуючо-в╕дтворююча головка}, яка анал╕зу╓ або зм╕ню╓
	записан╕ на поверхн╕ дан╕. Вс╕ пластини обертаються на
	сп╕льн╕й ос╕, типова швидк╕сть обертання склада╓ 3600 оберт╕в
	на хвилину, але диски з вищою виробничою потужн╕стю мають вищ╕
	швидкост╕. Головки можуть пересуватися вздовж рад╕уса пластин,
	╕ цей рух, по╓днаний з обертанням пластин, да╓ головкам
	можлив╕сть доступу до будь-яко╖ частини диску.

	Процесор (CPU) ╕ реальний диск сп╕лкуються через
	\defin{дисковий контролер}. Це зв╕льню╓ вс╕ ╕нш╕ частини
	комп'ютера в╕д необх╕дност╕ знати, як саме користуватися тим
	чи ╕ншим диском, бо дисков╕ контролери можуть виготовлятися
	таким чином, щоб мати один ╕ той-же ╕нтерфейс до
	комп'ютера. Коротше кажучи, комп'ютер просто може сказати
	"<гей, дисче, дай мен╕ те, що я хочу">, зам╕сть того, щоб
	передавати довг╕ посл╕довност╕ електричних сигнал╕в т╕льки щоб
	посунути головку у в╕дпов╕дне положення ╕ чекати п╕сля цього,
	щоб потр╕бне м╕сце диску попало п╕д читаючу
	головку. Насправд╕, ╕нтерфейс до дискового контролера все ще
	досить складна штука, але все-таки набагато прост╕ше, н╕ж в╕н
	м╕г би бути. Кр╕м того, контролер може робити деяк╕ ╕нш╕ реч╕,
	так╕, як кешування або автоматичну зам╕ну дефектних сектор╕в.

	Наведен╕ вище дан╕, практично все, що необх╕дно знати
	середньо-перес╕чному користувачев╕ про обладнання. Кр╕м
	згаданого ╓ ще ц╕ла в'язка вс╕ляких ╕нших причандаль, таких,
	як двигун, що оберта╓ пластини, електронн╕ штучки, як╕ керують
	роботою механ╕чних частин, але все це не ма╓ в╕дношення до
	розум╕ння принцип╕в роботи жорстких диск╕в.

	Магн╕тн╕ поверхн╕, як звичайно, розд╕лен╕ на концентричн╕
	к╕льця, що носять назву \defin{дор╕жок}, а ц╕ в свою чергу
	под╕лен╕ на \defin{сектори}. Такий под╕л використову╓ться для
	визначення положення на поверхн╕ жорсткого диску та для
	вид╕лення в╕льного простору для файл╕в. Щоб визначити потр╕бне
	м╕сце на диску звичайно кажуть "<поверхня 3, дор╕жка 5, сектор
	7">. Найчаст╕ше число сектор╕в ╓ сталим для вс╕х дор╕жок на
	диску, але деяк╕ диски прид╕ляють б╕льше сектор╕в на зовн╕шн╕
	дор╕жки (вс╕ сектори будуть мати в такому випадку однаковий
	ф╕зичний розм╕р, а, отже, б╕льше сектор╕в пом╕ститься на
	ближчих до зовн╕шнього периметру дор╕жках). Типовий сектор ма╓
	512~байт даних. Диск сам по соб╕ не може оперувати об'╓мами
	даних меншими, н╕ж розм╕р сектора.

		\begin{figure}[thb]
		\begin{center}
		\includegraphics{disks/hd-schematic.ps}
		\end{center}
		\caption{Схематичне зображення основних частин жорсткого диску.}
		\label{fig:hd-schematic}
		\end{figure}

	Кожна поверхня диску розд╕лена на дор╕жки (╕ сектори) так
	само, як ╕ ╕нш╕. Це означа╓ те, що, якщо головка на одн╕й з
	поверхонь знаходиться над певною дор╕жкою, то головки на вс╕х
	╕нших магн╕тних поверхнях знаходяться над такою ж
	поверхнею. Вс╕ в╕дпов╕дн╕ дор╕жки разом взят╕ називають
	\defin{цил╕ндром}. Пересування головок з одн╕╓╖ дор╕жки
	(цил╕ндру) до ╕ншо╖ займа╓ певний час. Отже, дан╕ краще
	розташувати таким чином, щоб дан╕, до яких доступ повинен
	виконуватися одночасно (наприклад, файл), розташовувалися в
	одному ╕ тому ж цил╕ндр╕. В такому раз╕ в╕дпада╓ необх╕дн╕сть
	пересування головок при доступ╕ до цих даних ╕, отже, це
	п╕двищу╓ швидк╕сть роботи. Не завжди виявля╓ться можливим
	розташувати файли таким чином, ╕ файли, як╕ виявляються
	записаними розкиданими по к╕лькох р╕зних ф╕зичних розд╕лах
	диску носять назву \defin{фрагментованих}.

	Число поверхонь, або головок (що, по сут╕, ╓ одним ╕ тим же),
	цил╕ндр╕в та сектор╕в сутт╓во в╕др╕зняються\intnote{В╕д одн╕╓╖
	модел╕ диску до ╕ншо╖, звичайно, а не в процес╕
	роботи.}. Сукупн╕сть вс╕х цих параметр╕в називають
	\defin{геометр╕╓ю} жорсткого диску. Геометр╕я диску часто
	запису╓ться в спец╕альн╕й пам'ят╕, що живиться в╕д батарейки,
	╕ носить назву \defin{CMOS RAM}\begin{intnote}Сказане в попередньому
	абзац╕ в╕дноситься, по сут╕, т╕льки до PC-Л╕накс╕в. 

	Запис геометр╕╖ диску в CMOS ╓ специф╕чною ознакою PC
	BIOS'╕в. ╤нш╕ системи користуються б╕льш розвиненими методами
	визначення геометр╕╖ диск╕в. Всього лиш к╕лька сл╕в для
	прикладу - в SunOS та Solaris ╓ спец╕альна база даних тип╕в
	диск╕в, в як╕й ставиться у в╕дпов╕дн╕сть р╕зн╕ типи диск╕в та
	╖х геометр╕╖. Тип диску визнача╓ться системою з його етикетки,
	яка записана в заголовку самого диску. Sparc Л╕накс теж не
	користу╓ться BIOS'ом для визначення геометр╕╖ диск╕в з то╖
	просто╖ причини, що комп'ютери Sun просто не мають BIOS'╕в. Я
	не знаю, як саме Sparc Л╕накс визнача╓ геометр╕ю диск╕в, тому
	буду радий, якщо хтось з Вас под╕литься з╕ мною знаннями.

	Також б╕льш сучасн╕ BIOS'и (практично вс╕, що випускаються на
	сьогодн╕шн╕й день - я не зустр╕чав в останн╕й час жодно╖ ново╖
	материнсько╖ плати PC без ц╕╓╖ установки) вм╕ють визначати
	типи диск╕в п╕д'╓днаних до системи. ╤ в╕д користувача не
	вимага╓ться вносити зм╕ни в установки BIOS'у п╕сля зм╕ни
	диск╕в. 

	 \end{intnote}. З ц╕╓╖ пам'ят╕ операц╕йна система д╕зна╓ться про диск п╕д
	час старту системи або драйвер╕в.

	На жаль BIOS\footnote{BIOS - це певна програма для початкового
	старту системи, яка запису╓ться в ROM комп'ютера. Вона
	в╕дпрацьову╓ початковий старт системи в╕д вмикнення живлення
	до того моменту, коли управл╕ння переда╓ться операц╕йн╕й
	систем╕.}\intnote{(див. ROM)} ма╓ певн╕ обмеження закладен╕
	при проектуванн╕, через як╕ виявля╓ться неможливим звертатися
	до дор╕жок, номер яких б╕льший за 1024 (тобто вказувати цей
	номер в CMOS RAM), що ╓ занадто малим для сучасних жорстких
	диск╕в. Щоб перейти через цю межу контролер придурю╓ться, що
	в╕н не зна╓ справжньо╖ геометр╕╖ диску ╕ \defin{переводить
	адреси}, запрошен╕ ком'ютером в так╕, як╕ б╕льше п╕дходять до
	рельно╖ ситуац╕╖. Наприклад, жорсткий диск може мати 8
	головок, 2048 дор╕жок ╕ 35 сектор╕в\footnote{чисто умовн╕
	числа}. Його контролер може дурити комп'ютер, що в╕н ма╓ 16
	головок, 1024 дор╕жки ╕ 35 сектор╕в на дор╕жку, не перевищуючи
	таким чином верньо╖ дозволено╖ меж╕ дор╕жок ╕ обчислю╓
	справжн╕ адреси на диску виводячи ╖х з тих, що надаються йому
	комп'ютером. Насправд╕ математика позаду такого обчислення
	може бути значно складн╕шою, бо числа можуть бути не такими
	гарними та гладенькими, як в наведеному приклад╕ (але, знову ж
	таки, це не ма╓ в╕дношення до загального розум╕ння принципу
	роботи). Таке переформування ф╕зичних адрес викривлю╓ уявлення
	системи про справжню орган╕зац╕ю диск╕в ╕ робить
	безперспективними спроби оптим╕зац╕╖ швидкост╕ доступу за
	рахунок розташування даних в межах одного цил╕ндру.
	
	Ц╕ проблеми переобчислення адрес стосуються т╕льки IDE
	диск╕в. SCSI диски використовують посл╕довн╕ номери сектор╕в
	(тобто, контролер переводить посл╕довний номер сектора в
	триплет "<головка-цил╕ндр-сектор">) ╕ зовс╕м ╕нший метод для
	сп╕лкування з процесором, отже вони повн╕стю ╕зольован╕ в╕д
	описано╖ проблеми. В╕дм╕тьте, однак, що ╕ у випадку ╕з SCSI
	дисками комп'ютер також може не знати справжньо╖ геометр╕╖
	диску.

	Через те, що Л╕накс часто не ма╓ ╕ найменшого поняття про
	справжню геометр╕ю диску, в╕н нав╕ть ╕ не дума╓ пом╕стити
	як╕сь дан╕ в межах одного цил╕ндру. Зам╕сть цього в╕н
	намага╓ться приписати кожному файлу посл╕довн╕ сектори, ╕ це в
	результат╕ да╓ приблизно такий же виграш в час╕. Ця проблема
	нав╕ть б╕льше ускладню╓ться кешами контролера диск╕в та
	автоматичним "<читанням наперед">\intnote{read ahead} контролера.

	Кожен жорсткий диск ма╓ св╕й власний спец╕альний файл. Загалом
	може бути два або чотири жорстких диски IDE в систем╕. Вони
	в╕дом╕ п╕д назвою \fn{/dev/hda}, \fn{/dev/hdb}, \fn{/dev/hdc}
	та \fn{/dev/hdd}. SCSI диски мають назви \fn{/dev/sda},
	\fn{/dev/sdb} ╕ т.д. В╕дпов╕дн╕ домовленост╕ щодо назв диск╕в
	╕снують також для ╕нших тип╕в пристро╖в. Детальн╕ дан╕ про
	типи пристро╖в маються в~\cite{device-list}. Майте на уваз╕,
	що спец╕альн╕ файли для ц╕лих диск╕в мають доступ до диск╕в
	ц╕лком, не звертаючи уваги на розд╕ли диск╕в (про це йдеться
	дал╕), ╕ при цьому виявля╓ться надзвичайно легко наробити лиха
	з ус╕ма розд╕лами, якщо не бути уважним. Спец╕альн╕ файли
	диск╕в част╕ше всього використовуються, щоб отримати доступ до
	MBR \intnote{main boot record - головний завантажувальний запис}
	(що теж буде обговорюватися дал╕).

\section{Гнучк╕ диски}

	Гнучк╕ диски складаються з гнучко╖ мембрани покрито╖ з одного
	або обох бок╕в магн╕тною речовиною, що схожа на ту, яка
	використову╓ться при виготовленн╕ жостких диск╕в. Гнучкий диск
	сам власне не ма╓ записуючо╖ чи читаючо╖ магн╕тно╖
	головки. Головка входить в склад приводу. Гнучкий диск
	анало╜╕чний до одн╕╓╖ пластини жорсткого диску з т╕╓ю
	р╕зницею, що його можна виймати з комп'ютера ╕ один ╕ той же
	прив╕д можна використовувати для багатьох диск╕в, в той час,
	як жорсткий диск - нерозд╕льний.

	Под╕бно до жорсткого диску гнучкий також розд╕лений на дор╕жки
	╕ сектори (де дв╕ в╕дпов╕дн╕ дор╕жки на обох боках диску
	утворюють цил╕ндр), але об'╓м ╕нформац╕╖, що запису╓ться на
	гнучкий диск значно менший.

	Прив╕д гнучкого диску в б╕льшост╕ випадк╕в може користуватися
	к╕лькома р╕зними типами диск╕в, наприклад, 3.5
	дюймовий дисков╕д може використовувати як диски в╕дформатован╕
	на 720~кБайт, так ╕ диски в╕дформатован╕ на
	1.44~МБайт. Приймаючи до уваги, що з кожним окремими форматом
	система повинна поводитися трохи ╕накше, н╕ж з ╕ншим, ╕
	система повинна розум╕ти, ск╕льки ╕нформац╕╖ м╕стить той чи
	╕нший диск, ста╓ зрозум╕лим, чому для кожного дисководу
	ма╓ться по к╕лька р╕зних спец╕альних файл╕в. Отже,
	\fn{/dev/fd0H1440} в╕дпов╕да╓ першому дисковому приводу
	(\texttt{fd0}), який ма╓ бути 3.5 дюймовим
	дисководом, який використову╓ 3.5-дюймов╕ дискети
	високо╖ щ╕льност╕ запису (\texttt{H}), об'╓мом 1440~кБайт
	(\texttt{1440}), або, просто кажучи, звичан╕ трьохдюймов╕
	дискети. Б╕льше ╕нформац╕╖ про назви спец╕альних пристро╖в
	дисковод╕в ма╓~\cite{device-list}.

	Назви дисковод╕в в Л╕накс╕ досить складн╕, отож був створений
	спец╕альний тип спец╕ального файлу для дискет, який самост╕йно
	визнача╓ тип дискети, яка знаходиться в дисковод╕. В╕н по черз╕ 
	намага╓ться прочитати перший сектор дискети, користуючись
	р╕зними форматами до тих п╕р, поки не в╕дшука╓
	потр╕бний. При цьому, звичайно, потр╕бно, щоб дискета спершу
	була в╕дформатована. Автоматичн╕ пристро╖ дискет називаються
	\fn{/dev/fd0}, \fn{/dev/fd1} ╕ т.д.

	Параметри, як╕ автоматичний драйвер використову╓ для доступу
	до дискет можна задавати за допомогою програми
	\cmd{setfdprm}. Це може знадобитися, якщо Ви користу╓тесь
	дискетами, як╕ не в╕дпов╕дають н╕яким стандартам форматування,
	тобто мають незвичайну к╕льк╕сть сектор╕в, або, якщо з яко╖сь
	причини автоматичне визначення формату на спрацьову╓, або ж,
	якщо в╕дпов╕дний спец╕альний файл драйвера на знайдено в
	систем╕.

	Додатково до вс╕х стандартних формат╕в дискет Л╕накс може
	працювати з багатьма нестандартними форматами. Для деяких з
	них потр╕бн╕ спец╕альн╕ програми для фотматування. Ми не
	будемо зараз зупинятися на них, але Ви можете самост╕йно
	подивитися файл \fn{/etc/fdprm}. В ньому визначаються вс╕ т╕
	формати, як╕ п╕дтриму╓ \cmd{setfdprm}.

	Операц╕йна система повинна знати, коли зам╕ню╓ться диск в
	привод╕, щоб не використовувалися дан╕ в╕д попереднього диску
	(як╕ можуть залишатися певний час в пам'ят╕). На жаль
	сигнальна л╕н╕я, що служить для цього часто бува╓ з╕псованою,
	╕, кр╕м того, що найг╕рше, з╕псовану л╕н╕ю часто бува╓ важко
	пом╕тити при робот╕ в MS-DOS. Якщо Ви пом╕ча╓те, що прив╕д
	дискети почина╓ себе поводити "<дивно">, то описане може бути
	проблемою цього. Цьому можна зарадити т╕льки одним чином -
	в╕дремонтувавши прив╕д.


\section{Приводи CD-ROM}

	Прив╕д CD-ROM використову╓ покритий пол╕мером диск для
	оптичного считування ╕нформац╕╖. ╤нформац╕я запису╓ться на
	поверхн╕ диску\footnote{Тобто на поверхн╕ всередин╕ диску "--- на
	металевому диску всередин╕ пол╕мерного покриття.} у вигляд╕
	маленьких `д╕рочок' розташованих по сп╕рал╕ в╕д центру до
	кра╖в. Прив╕д спрямову╓ лазерний пром╕нь для считування
	╕нформац╕╖ ╕з сп╕рально╖ канавки. Коли пром╕нь попада╓ у
	впадину, в╕н в╕дбива╓ться одним чином, а коли на гладку
	поверхню - ╕ншим. Завдяки цьому можна легко закодовувати
	╕нформац╕ю у вигляд╕ дв╕йкових код╕в. Все ╕нше - дурнички -
	звичайна механ╕ка. 

	Пор╕вняно з жорсткими дисками, приводи CD-ROM --
	пов╕льн╕. Якщо типовий жорсткий диск ма╓ час
	доступу\intnote{seek time} менше 15~м╕л╕секунд, швидкому
	CD-ROM'у потр╕бно на це десят╕ дол╕ секунди. Д╕йсна швидк╕сть
	передач╕ ╕нформац╕╖ досить висока - сотн╕ к╕лобайт за
	секунду. Пов╕льн╕сть роботи привод╕в не дозволя╓
	використовувати ╖х для зам╕ни жорстких диск╕в, хоча це ╕
	можливо (деяк╕ компан╕╖ продають компакти Л╕накса з `живою'
	файловою системою на ньому, яка робить установку Л╕накса
	прост╕шою ╕ одночасно збер╕га╓ дисковий прост╕р). Найб╕льш
	придатн╕ компакт-диски для установки нового програмного
	забезпечення, бо швидк╕сть роботи не ма╓ такого великого
	значення при цьому.

	╤сну╓ к╕лька р╕зних способ╕в орган╕зац╕╖ ╕нформац╕╖ на
	компакт╕. Найб╕льш в╕домий стандарт - м╕жнародний стандарт
	ISO~9660. В╕н визнача╓ дуже м╕н╕мал╕стську файлову систему,
	яка нав╕ть прим╕тивн╕ша за MS-DOS'╕вську. З ╕ншого боку вона
	наст╕льки проста, що кожна сучасна операц╕йна система зд╕бна
	використовувати ╖╖ ╕ в╕дображати ╖╖ на `р╕дну' файлову
	систему. 

	Для нормального використання в Юн╕кс╕ ISO~9660 не
	годиться. Через це було розроблене розширення до не╖, назване
	"<Розширення Рок Р╕дж">\intnote{Rock Ridge extension}. Рок
	Р╕дж дозволя╓ використання довгих ╕мен файл╕в, символ╕чн╕
	ссилки та ╕нш╕ Юн╕ксовськ╕ причандалля, ╕ робить звичайний
	компакт б╕льш-менш схожим на сучасну файлову систему
	Юн╕кса. Кр╕м того файлова система Рок Р╕дж все ще залиша╓ться
	нормальною файловою системою ISO~9660, що дозволя╓
	використовувати ╖╖ ╕ншими операц╕йними системами. Л╕накс
	п╕дтриму╓ обидв╕ з них, як ISO~9660 так ╕ Рок Р╕дж, причому
	розширення розп╕знаються та використовуються автоматично.

	Але файлова система - все ще т╕льки п╕в дороги. Б╕льш╕сть
	компакт-диск╕в мають записан╕ програми для доступу до даних на
	цьому ж диску, ╕, на жаль, б╕льш╕сть цих програм не працюють в
	Л╕накс╕ (кр╕м, х╕ба що, за допомогою dosemu - емулятора MS-DOS для
	Л╕накса).

	Прив╕д компакт-диску доступний через в╕дпов╕дний спец╕альний
	файл пристрою. Прив╕д може бути п╕дключений до комп'ютера
	одним ╕з к╕лькох можливих способ╕в: через SCSI ╕нтерфейс,
	через звукову плату або через EIDE. Хакерськ╕ зм╕ни до
	програм, для того, щоб це стало можливим випадають з поля зору
	ц╕╓╖ книжки, але тип з'╓днання визнача╓ться спец╕альним
	файлом. Детал╕ див╕ться в~\cite{device-list}.

\section{Стр╕чки}

	Прив╕д магн╕тно╖ стр╕чки використову╓ стр╕чку под╕бну
	до\footnote{Але, звичайно ж, зовс╕м ╕ншу.} магн╕тофонних
	касет. Стр╕чка ╓ посл╕довною за сво╓ю натурою, що означа╓, що
	для того, щоб д╕статися до якогось певного м╕сця на стр╕чц╕,
	Ви повинн╕ пройти через вс╕ попередн╕ записи. На в╕дм╕ну в╕д
	стр╕чки, до даних на диску можна доступатися в дов╕льному
	порядку, тобто Ви можете перестрибнути до будь-якого бажаного
	м╕сця на диску. Через посл╕доний доступ до даних на стр╕чц╕,
	стр╕чки - надзвичайно пов╕льн╕ пристро╖.

	З ╕ншого боку, стр╕чки в╕дносно дешев╕ при виготовленн╕, саме
	через те, що ╖м не потр╕бно бути швидкими. Кр╕м того ╖х можна
	зробити довгими ╕ тому вони можуть м╕стити велик╕ об'╓ми
	даних. Тому, в основному, стр╕чки використовуються для
	арх╕вування та створення резервних коп╕й, при яких не потр╕бн╕
	висок╕ швидкост╕, але необх╕дн╕ дешевизна та велика ╓мн╕сть.
	
\section{Форматування}

	\defin{Форматування} - це процес запису спец╕альних позначок
	на магн╕тних нос╕ях, як╕ використовуються для позначення
	дор╕жок та сектор╕в. До форматування магн╕тна поверхня - це
	повна м╕шанина магн╕тних сигнал╕в. П╕сля цього в хаос
	вноситься певних порядок за рахунок проведення меж дор╕жок та
	магн╕тних позначок, як╕ розд╕ляють ╖х на сектори. Справжн╕й
	процес не наст╕льки простий, але це не стосу╓ться сут╕
	справи. Що ╓ насправд╕ важливим - це, те, що диском неможливо
	користуватися без попереднього форматування.

	Трохи вводить в оману терм╕ноло╜╕я, що застосову╓ться тут - в
	MS-DOS слово `форматування' в╕дноситься до процесу створення
	файлово╖ системи (про що йдеться трохи дал╕). Але насправд╕
	╕сну╓ два процеси, як╕ часто об'╓днуються, особливо для
	дискет. Тод╕, коли треба в╕др╕зняти ц╕ два процеси, те, що
	справд╕ ╓ форматуванням називають \begin{defin}форматуванням низького 
	р╕вня\begin{intnote}low-level formatting\end{intnote} \end{defin}
	, а про створення
	файлово╖ системи говорять, що це - \begin{defin}форматування
	високого р╕вня\begin{intnote}high-level formatting\end{intnote}\end{defin}. В св╕т╕ Юн╕кса
	про ц╕ два процеси говорять `форматування' та `створення
	файлово╖ системи', отже це ╕ будуть т╕ терм╕ни, як╕
	використовуються в ц╕й книжц╕.
	
	Для IDE та деяких SCSI диск╕в форматування фактично
	викону╓ться на завод╕ ╕ його не потр╕бно робити вдруге, тобто,
	б╕льш╕сть людей взагал╕ не повинн╕ турбуватися про
	форматування. Насправд╕, форматування може нав╕ть привести до
	того, що диск буде працювати г╕рше, наприклад, через те, що,
	можливо, форматувати необх╕дно якимось спец╕альним чином, так,
	щоб автоматично зам╕нювати дефектн╕ сектори.

	Диски, як╕ потр╕бно або можна форматувати, часто вимагають
	спец╕ально╖ програми для цього - лог╕ка, що використову╓ться
	для форматування в╕др╕зня╓ться в╕д диску до диску. Форматуюча
	програма часто або знаходиться в BIOS'╕ контролера або
	постача╓ться у вигляд╕ програми для MS-DOS, н╕ тим, н╕ ╕ншим не
	просто користуватися ╕з Л╕накса. 

	П╕д час форматування можна пом╕тити деяк╕ дефектн╕ м╕сця на
	диску, що називаються \defin{дефектними блоками} або
	\defin{дефектними секторами}. В деяких випадках прив╕д
	турбу╓ться про них самост╕йно, але нав╕ть якщо це так, якщо
	к╕льк╕сть дефект╕в зб╕льшу╓ться, то щось треба з ними робити
	для того, щоб не користуватися дефектними м╕сцями на
	диску. Лог╕ка, що застосову╓ться для цього, вбудована в
	файлову систему. Дал╕ буде йтися про те, як додати таку
	╕нформац╕ю до файлово╖ системи. Додатково можна створити
	невеликий розд╕л на диску, який буде покривати т╕льки дефектн╕
	област╕, бо при занадто велик╕й к╕лькост╕ зб╕йних блок╕в
	нав╕ть файлова система може мати з ними певн╕ труднощ╕.

	Дискети форматуються командою \cmd{fdformat}.  Як параметр
	команд╕ повинна надаватися назва спец╕ального файлу
	дискети. Наприклад, для форматування 3.5-дюймово╖ дискети
	високо╖ щ╕льност╕ використову╓ться така команда:

		%
\begin{quote}\tt
\verb|$| {\sl fdformat /dev/fd0H1440} \\
\verb|Double-sided, 80 tracks, 18 sec/track. Total capacity 1440 kB.| \\
\verb|Formatting ... done| \\
\verb|Verifying ... done| \\
\verb|$|
\rm\end{quote}
		%
	
	В╕дм╕тимо, що якщо Ви хочете користуватися спец╕альним файлом
	з автоматичним визначенням типу дисекети, Ви {\em повинн╕}
	встановити параметри дискети командою \cmd{setfdprm} до
	цього. Наступн╕ команди будуть мати той ж результат, що й
	попередн╕:

		%
\begin{quote}\tt
\verb|$| {\sl setfdprm /dev/fd0 1440/1440} \\
\verb|$| {\sl fdformat /dev/fd0} \\
\verb|Double-sided, 80 tracks, 18 sec/track. Total capacity 1440 kB.| \\
\verb|Formatting ... done| \\
\verb|Verifying ... done| \\
\verb|$|
\verb|$|
\rm\end{quote}
		%

	Сл╕д користуватися типом спец╕ального файлу, що в╕дпов╕да╓
	типу дискети ╕ не варто форматувати дискету на об'╓ми б╕льший,
	н╕ж той, на який вона розрахована.

	\cmd{fdformat} також перев╕рить дискету, тобто, пом╕тить
	зб╕йн╕ блоки. В╕н буде намагатися записати (в╕дформатувати)
	дефектн╕ блоки по к╕лька раз╕в (Ви це почу╓те, звук приводу
	при цьому зм╕ню╓ться сутт╓во). Якщо дискета не надто з╕псована
	(невелик╕ часточки бруду, що попали на записуючу головку,
	деяк╕ др╕бн╕ помилки читання, тощо), \cmd{fdformat} пропустить
	╖х, але сутт╓в╕ помилки спричинять зупинку процесу
	перев╕рки. Ядро надруку╓ пов╕домлення про кожну з помилок
	вводу/виводу, вс╕ вони будуть направлятися на консоль або в
	файл \fn{/usr/adm/messages}\begin{intnote}тобто ма╓ться на уваз╕
	\fn{/var/log/messages}. Б╕льш╕сть Юн╕кс╕в традиц╕йно
	користуються директор╕╓ю \fn{/var/adm} для вс╕х файл╕в
	ре╓страц╕╖ пов╕домлень, ал╕ Л╕накс зм╕нив цю традиц╕ю ╕ вв╕в
	директор╕ю \fn{/var/log}, тож вона ╕ мала б бути тут вказаною,
	але в ори╜╕нал╕ твору було вказано саме цю назву. Наприклад, в
	мо╓му RedHat 5.0, на якому це пишеться, тако╖ директор╕╖
	(\fn{/usr/adm}) нема╓, тож будьте уважними з назвами
	директор╕й.\end{intnote} якщо працю╓ \cmd{syslog}. \cmd{fdformat} однак не
	буде пов╕домляти, де саме трапилася помилка, але саму це якраз
	дуже мало кого хвилю╓ в наш час, оск╕льки при дешевизн╕
	гнучких диск╕в зараз набагато легше (╕ часто дешевше -Д.К.)
	викинути зб╕йну дискету.

	% 
	\begin{quote}\tt
\verb|$| {\sl fdformat /dev/fd0H1440} \\
\verb|Double-sided, 80 tracks, 18 sec/track. Total capacity 1440 kB.| \\
\verb|Formatting ... done| \\
\verb|Verifying ... read: Unknown error| \\
\verb|$|
		\rm\end{quote}
		%

	Для того, щоб в╕дшукати зб╕йн╕ блоки на будь-якому диску (в
	тому числ╕ ╕ на дискет╕) можна скористатися командою
	\cmd{badblocks}. Вона не формату╓ диску, тобто нею можна
	скористуватися нав╕ть для перев╕рки ╕снуючих файлових
	систем. Для прикладу розгляньте команду, яка перев╕рила
	3.5 дюймову дискету ╕ видала ╕нформац╕ю про два
	зб╕йних блоки:

		%
		\begin{quote}\tt
\verb|$| {\sl badblocks /dev/fd0H1440 1440} \\
\verb|718| \\
\verb|719| \\
\verb|$|
		\rm\end{quote}
		%

	Команда \cmd{badblocks} просто друку╓ номери знайдених нею
	зб╕йних блок╕в. Б╕льш╕сть файлових систем вм╕ють обходити
	зб╕йн╕ блоки. В файлов╕й систем╕ м╕ститься список ╕з зб╕йними
	блоками. Цей список створю╓ться при створенн╕ само╖ файлово╖
	системи, але до нього можна додавати нов╕ блоки ╕
	п╕зн╕ше. Спочатку список зб╕йних блок╕в створю╓ться командою
	\cmd{mkfs} (Яка створю╓ файлову систему)\begin{intnote}Просто для
	дов╕дки: в SunOS та Solaris анало╜ом команди \cmd{mkfs} ╓
	команда \cmd{newfs}, р╕зниця невелика, але спробуй-но
	в╕дформатуй диск в SunOS, якщо до цього користувався т╕льки
	Л╕наксом.\end{intnote}, але п╕сля цього перев╕ряти файлову систему
	потр╕бно командою \cmd{badblocks} ╕ додавати нов╕ блоки до
	списку зб╕йних треба командою \cmd{fsck}. Опис команд
	\cmd{mkfs} та \cmd{fsck} ╕де дал╕.
	
	Б╕льш╕сть сучасних диск╕в достатньо "<розумн╕"> для того, щоб
	визначати сво╖ власн╕ зб╕йн╕ блоки ╕ щоб спробувати ╖х
	в╕дновити, використовуючи ╕нш╕ зарезерован╕ для ц╕╓╖ мети
	блоки. Ця операц╕я непом╕тна ("<прозора">) для операц╕йно╖
	системи. Якщо Вас ц╕кавить, чи це ╓ под╕бна функц╕я у Ваших
	дисках, то, мабуть, ця функц╕я повинна бути описана в
	документац╕╖ до диск╕в. Але нав╕ть такий диск може в╕дмовити,
	коли число зб╕йних блок╕в зб╕льшу╓ться занадто. Але, напевне,
	що коли таке трапиться, то диск буде нарешт╕ вже наст╕льки
	застар╕лим, що, певне, у Вас не виникне нав╕ть ╕ бажання ним
	користуватися.

\section{Розд╕ли}\intnote{partitions}

	Жорсткий диск можна розд╕лити на к╕лька
	\defin{розд╕л╕в}. Кожен такий розд╕л може працювати, як
	окремий диск. ╤дея поляга╓ в тому, що, наприклад, якщо Ви
	ма╓те диск, то, можливо, захочете встановити к╕лька
	операц╕йних систем на ньому. В цому випадку можна розд╕лити
	диск на к╕лька п╕дрозд╕л╕в. Кожна операц╕йна система
	користу╓ться сво╖м розд╕лом, як ╖й захочеться ╕ не допуска╓ться
	до ╕нших розд╕л╕в. Таким чином р╕зн╕ операц╕йн╕ системи можуть
	мирно сп╕в╕снувати на одному ╕ тому ж жорсткому диску. Якби це
	було не можливо, потр╕бно було б купувати окремий диск для
	кожно╖ встановлено╖ системи.

	Розд╕ли неможливо створити на дискетах. Не ╕сну╓ н╕яких
	техноло╜╕чних перешкод щоб це зробити, але оск╕льки так╕
	розд╕ли будуть занадто малими, навряд чи комусь це
	знадобиться. Оск╕льки компакт диски набагато зручн╕ше
	використовувати як одне ц╕ле, вони теж практично н╕коли не
	розбиваються на розд╕ли. ╤ дуже р╕дко виника╓ потреба мати
	к╕лька операц╕йних систем на одному компакт╕ \intnote{Хоча це
	╕ можливо ╕ нав╕ть, як св╕дчить м╕й власний досв╕д,
	використову╓ться дуже часто. Компакт може мати к╕лька
	п╕дрозд╕л╕в, видимих для р╕зних систем. Наприклад, дуже багато
	програмного забезпечення розпровсюджу╓ться в вигляд╕ диску з
	двома розд╕лами - один з файловою системою FAT для MS-DOS та
	його пох╕дних В╕ндовс╕в, а другий з файловою системою HFS для
	Мак╕нтош╕в. Коли цей диск вставля╓ться в Windows, то в╕н,
	звичайно-ж, не бачить файлово╖ системи для Мака (HFS) ╕
	навпаки. ╤ т╕льки в Л╕накс╕ можна змонтувати обидв╕ з них.}.

\subsection{Головний завантажувальний запис, завантажувальн╕ сектори та таблиця
	розд╕л╕в.}\intnote{Головний завантажувальний запис:MBR - Main Boot
	Record, завантажувальн╕ сектори: boot sectors, таблиця
	розд╕л╕в: partition table}.

	Вс╕ дан╕ про те, як диск розд╕лений на розд╕ли, збер╕гаються в
	його найпершому сектор╕ (тобто - в першому сектор╕ першо╖
	дор╕жки на перш╕й магн╕тн╕й поверхн╕). Цей перший сектор
	\intnote{з номером 0, як ╕ все, що стосу╓ться комп'ютер╕в,
	почина╓ться з 0, а не з 1} ╕ ╓ \defin{головним загpузочним
	записом} (MBR) диску, це ╓ той запис, який чита╓ться BIOS'ом ╕
	почина╓ в╕дпрацьовувати, коли комп'ютер старту╓. В MBR
	запису╓ться невелика програма, яка чита╓ таблицю розд╕л╕в
	диск╕в, перев╕ря╓, який з розд╕л╕в ╓ активним (тобто, з нього
	можна завантажити систему) ╕ чита╓ перший сектор цього розд╕лу -
	\defin{завантажувальний сектор} цього розд╕лу (MBR - це теж
	завантажувальний сектор, але в╕н - спец╕альний серед сектор╕в ╕
	тому назива╓ться ╕накше). В цьому ╕ншому завантажувальному сектор╕
	записана ╕нша невеличка програмка, яка чита╓ початок
	операц╕йно╖ системи записано╖ в даному розд╕л╕ (якщо,
	звичайно, з цього розд╕лу можна завантажитися) ╕ п╕сля цього
	переда╓ управл╕ння операц╕йн╕й систем╕.

	Схеми розбиття на розд╕ли не вмонтован╕ в апаратуру
	комп'ютера, ╕ нав╕ть BIOS не зна╓ про них. Це всього-навсього
	домовлен╕сть, яка викону╓ться багатьма операц╕йними
	системами. Правда, не вс╕ма операц╕йними системами, але ця
	менш╕сть з них ╓ скор╕ше виключенням. Деяк╕ операц╕йн╕ системи
	можуть користуватися одним розд╕лом на диску ╕ под╕ляють цей
	розд╕л всередин╕ на п╕дрозд╕ли. Системи цього типу мирно
	сп╕в╕снують з ╕ншими системами (включаючи Л╕накс), ╕ для них
	не потр╕бн╕ н╕як╕ спец╕альн╕ п╕дходи. Але операц╕йн╕ системи,
	як╕ не п╕дтримують розд╕ли диску не можуть сп╕в╕снувати з
	╕ншими системами зовс╕м.

	Для власно╖ безпеки завжди краще мати таблицю розд╕л╕в диску
	записаною в себе на аркуш╕ паперу, так що нав╕ть з╕псовану
	таблицю можна було б в╕дновити п╕сля краху (якщо з╕псована
	т╕льки таблиця розд╕лу, Ви не загубите сво╖х
	файл╕в). З╕псовану таблицю можна в╕дновити за допомогою
	команди \cmd{fdisk}, а подивитися, яка Ваша таблиця - командою
	\cmd{fdisk -l}:
		%
	\begin{quote}\tt
\verb|$| \textsl{fdisk -l /dev/hda} \\
\verb|| \\
\verb|Disk /dev/hda: 15 heads, 57 sectors, 790 cylinders| \\
\verb|Units = cylinders of 855 * 512 bytes| \\
\verb|| \\
\verb|   Device Boot  Begin   Start     End  Blocks   Id  System| \\
\verb|/dev/hda1           1       1      24   10231+  82  Linux swap| \\
\verb|/dev/hda2          25      25      48   10260   83  Linux native| \\
\verb|/dev/hda3          49      49     408  153900   83  Linux native| \\
\verb|/dev/hda4         409     409     790  163305    5  Extended| \\
\verb|/dev/hda5         409     409     744  143611+  83  Linux native| \\
\verb|/dev/hda6         745     745     790   19636+  83  Linux native| \\
\verb|$|
	\rm\end{quote}

\subsection{Розширен╕ та лог╕чн╕ розд╕ли}

	Початкова схема розд╕лу диск╕в на розд╕ли, яка прижилася в
	св╕т╕ "<п╕-с╕"> дозволяла мати всього чотири розд╕ли. Дуже
	швидко виявилося, що цього недостатньо (просто тому,
	наприклад, що багато хто хоче мати б╕льше чотирьох систем на
	сво╓му комп'ютер╕: Л╕накс, DOS, OS/2, Minix, FreeBSD, NetBSD
	чи Windows/NT). Але в основному тому, що часто краще мати
	к╕лька розд╕л╕в для одн╕╓╖ системи. Наприклад, прост╕р для
	своп╕н╜у для п╕двищення швидкост╕ роботи (див. дал╕) краще
	пом╕стити на його власний розд╕л зам╕сть того, щоб тримати на
	основному.

	Щоб перейти через ц╕ проектн╕ обмеження п╕зн╕ше були введен╕
	\defin{розширен╕ розд╕ли}\intnote{extended partition}. Це
	нововведення дозволя╓ розбити \defin{основний
	розд╕л}\intnote{primary partition} на п╕дрозд╕ли. Таким чином
	розд╕лений основний розд╕л називають \defin{розширеним
	розд╕лом}, а п╕дрозд╕ли, на як╕ розбитий основний розд╕л -
	\defin{лог╕чними розд╕лами}\intnote{logical partition}. Вони
	працюють так саме, як ╕ основн╕ \footnote{Нелог╕чн╕?} розд╕ли,
	але процес створення ╖х ╕нший. Швидк╕сть ╖х роботи не
	в╕др╕зня╓ться в╕д основних розд╕л╕в.

	Структура диску може мати вигляд, як показано на
	рисунку~\ref{fig:hard-disk-layout}. Диск розд╕лений на три
	основн╕ розд╕ли, другий з яких розд╕лений на два лог╕чних
	розд╕ли. Частина диску не належить жодному розд╕лу. Весь диск,
	як вц╕лому, так ╕ кожний з його основних розд╕л╕в мають по
	завантажувальному сектору.		
	%
		\begin{figure}[thb]
		\begin{center}
		\includegraphics{disks/hd-layout.ps}
		%\include{hd-layout}
		\end{center}
		\caption{Зразок розд╕лу диску.}
		\label{fig:hard-disk-layout}
		\end{figure}

\subsection{Типи розд╕л╕в диску}

	Таблиц╕ розд╕л╕в диску або завантажувальн╕ сектори (один з яких ╓
	MBR, а ╕нш╕ знаходяться на розширених розд╕лах) мають по одому
	байту (тобто - один байт на кожен дисковий розд╕л - чи то
	основний, чи то лог╕чний), в якому запису╓ться тип
	в╕дпов╕дного розд╕лу. Це робиться для того, щоб можна було
	визначати тип операц╕йно╖ системи, як╕й належить даний розд╕л,
	або призначення даного розд╕лу. Мета цього - запоб╕гти
	випадкам, коли дв╕ р╕зн╕ операц╕йн╕ системи можуть випадково
	скористуватися одним ╕ тим же розд╕лом.  Однак, насправд╕,
	операц╕йн╕ системи не дуже то стурбован╕ р╕зними байтами
	розд╕л╕в. Наприклад, Л╕накс не зверта╓ на цей байт жодно╖
	уваги. Що ще г╕рше - деяк╕ з операц╕йних систем користуються
	цим байтом нев╕рно. Наприклад, як м╕н╕мум деяк╕ верс╕╖
	DR-DOS'у ╕гнорують найстарший б╕т даного байту, в той час, як
	╕нш╕ - в╕дносяться до нього з повагою.

	Жодна стандартизац╕йна ╕нстанц╕я не може вказати, яке значення
	байту в╕дпов╕да╓ чому, але деяк╕ найб╕льш вживан╕ величини
	приведен╕ в таблиц╕~\ref{tab:partition-ids}. Ця ж сама таблиця
	ма╓ться в команд╕ \cmd{fdisk} Л╕накса.

\begin{table}[ht]
\caption{Типи розд╕л╕в жостких диск╕в (з програми \cmd{fdisk} Л╕накса).}
\begin{center}
\begin{tabular}{rl rl rl rl}
\hline
0 & Empty               & 40 & Venix 80286  & 94 & Amoeba BBT     \\
1 & DOS 12-bit FAT      & 51 & Novell?      & a5 & BSD/386        \\
2 & XENIX root          & 52 & Microport    & b7 & BSDI fs        \\
3 & XENIX usr           & 63 & GNU HURD     & b8 & BSDI swap      \\
4 & DOS 16-bit $<$32M   & 64 & Novell       & c7 & Syrinx         \\
5 & Extended            & 75 & PC/IX        & db & CP/M           \\
6 & DOS 16-bit $\ge$32M & 80 & Old MINIX    & e1 & DOS access     \\
7 & OS/2 HPFS           & 81 & Linux/MINIX  & e3 & DOS R/O        \\
8 & AIX                 & 82 & Linux swap   & f2 & DOS secondary  \\
9 & AIX bootable        & 83 & Linux native & ff & BBT            \\
a & OS/2 Boot Manag     & 93 & Amoeba       &    &                \\
\hline
\end{tabular}
\end{center}
\label{tab:partition-ids}
\end{table}

\subsection{Розд╕лення жорсткого диску на розд╕ли}

	╤сну╓ багато програм для створення та знищення
	розд╕л╕в. Б╕льш╕сть операц╕йних систем мають сво╖ власн╕
	вар╕анти таких програм, ╕ тому, взагал╕ кажучи, уявля╓ться
	доц╕льним користуватися в кожн╕й операц╕йн╕й систем╕ ╖╖
	власною програмою для створення розд╕л╕в ц╕╓╖ операц╕йно╖
	системи, на той випадок, якщо така програма робить щось дивне
	чи не задокументоване, або таке, чого ╕нш╕ робити не
	вм╕ють. Багато вар╕ант╕в таких програм називаються \cmd{fdisk}
	, включаючи ╕ Л╕накс\begin{intnote}Зда╓ться, що це в╕дноситься
	т╕льки до `PC-пох╕дних' операц╕йних систем. `Справжн╕' Юн╕кси
	(типу SunOS, Solaris) мають програму, що назива╓ться
	\cmd{format}. Основна в╕дм╕нн╕сть м╕ж цими двома в тому, що
	\cmd{format} (насл╕дуючи кращ╕ традиц╕╖ Юн╕кс╕в) розум╕╓
	команди, тод╕, коли вони приходять не з клав╕атури, а з
	скрипту (╕з STDIN), тобто ма╓ться можлив╕сть автоматизувати
	процес розбиття диску на розд╕ли, що надзвичайно важливо в
	близьких до промислових умов, коли потр╕бно множити
	(`клонувати') комп'ютерн╕ системи покладаючись на
	автоматизац╕ю. Можлив╕сть скриптування процес╕в завжди була ╕
	буде найб╕льшою перевагою Юн╕кса над ╕ншими загальновживаними
	системами.\end{intnote}. Подробиц╕ використання \cmd{fdisk} наведен╕ в
	стор╕нц╕ п╕дказки для не╖. Команда \cmd{cfdisk} под╕бна за
	функц╕ями до \cmd{fdisk}, але ма╓ кращий вигляд на екран╕
	(повноекранний ╕нтерфейс).

	При використанн╕ IDE диск╕в стартовий розд╕л (тобто розд╕л, на
	якому м╕ститься ядро операц╕йно╖ системи) повинен лежати
	повн╕стю в межах перших 1024 цил╕ндр╕в диску. Це вимага╓ться
	через те, що при старт╕ системи диск використову╓ться через
	BIOS (до того, як система переходить в захищений
	режим\begin{intnote}Знову ж таки - данина `важкому дитинству' PC
	пов'язаномих з DOSом. В╕домий вс╕м максимум у 640 кБайт
	оперативно╖ пам'ят╕ - ще один ╕з приклад╕в спадщини. Саме
	через те, що PC працю╓ в стандартному режим╕ (standard mode)
	п╕д час завантаження, виника╓ необх╕дн╕сть компресувати ядро
	Л╕накса програмою \cmd{gzip} - ядро не пом╕ща╓ться повн╕стю в
	перш╕ 640кБайт пам'ят╕. ╤ ще раз - це особлив╕сть т╕льки
	PC-Л╕накса, н╕ ╕нш╕ Л╕накси, н╕ ╕нш╕ Юн╕кси не мають потреби
	компресувати ядро.\end{intnote}), а BIOS не зна╓ про те, що робити з
	б╕льше, н╕ж 1024-ма цил╕ндрами. ╤нколи можливо користуватися
	стартовим розд╕лом, який не весь лежить в межах 1024
	цил╕ндр╕в. Але це працю╓ т╕льки до тих п╕р, поки вс╕ файли,
	як╕ чита╓ BIOS, знаходяться у вказаних межах. ╤ оск╕льки ╓
	практично неможливим керувати розташуванням файл╕в на диску,
	то уявля╓ться \emph{страшенно поганою ╕де╓ю} користуватися
	таким розд╕лом. Ви н╕коли не зможете сказати напевне, чи
	завантажиться Ваш комп'ютер п╕сля поновлення ядра чи п╕сля
	дефрагментац╕╖ диска. Тому будьте особливо обережн╕ ╕
	визначайте Ваш стартовий розд╕л так, щоб в╕н в╕д початку до
	к╕нця лежав на перших 1024 цил╕ндрах \begin{intnote}Можливо в когось
	виникне питання, чому не виника╓ така проблема при робот╕ з
	DOS або з його пох╕дними - Windows'ами. Справа не в кращ╕й
	орган╕зац╕╖ Windows, а навпаки - в прим╕тивн╕шому п╕дход╕ до
	процесу старту системи. Якщо Ви коли-небудь в DOS'╕
	користувалися командою \cmd{sys} (яка переносить файли
	операц╕йно╖ системи з стартового диску на ╕нший диск,
	наприклад на дискету - робить цей диск системним або
	стартовим), то можливо пом╕тили, що не у вс╕х випадках таке
	перенесення можливе. Якщо дискета була т╕льки, що
	в╕дформатована, то система перенесеться залюбки, а якщо Ви до
	цього встигли записати на не╖ хоча б один файл, то команда
	\cmd{sys} в╕дмовиться встановлювати систему. Це в╕дбува╓ться
	тому, що DOS встановлю╓ системн╕ файли т╕льки в перших
	секторах диску ╕ не може прочитати ядро системи (в DOS'╕ це
	два невидимих файли, що завжди лежать в корн╕ диску C: -
	MSDOS.SYS або PCDOS.SYS залежно в╕д виробника
	системи (Якщо ще ╓ люди, як╕ пам'ятають, що DOS
	виробляв колись не т╕льки Майкрософт, ╕ не завжди в минул╕
	роки DOS мав преф╕кс "<MS">) та IO.SYS), якщо це ядро
	знаходиться в ╕ншому м╕сц╕ диску.

	Результатом такого п╕дходу ╕ ╓ те, що: з одного боку система
	завжди автоматично знаходиться в межах 1024 перших цил╕ндр╕в,
	а з ╕ншого - несистемний диск можна зробити системним т╕льки
	наново в╕дформатувавши його (що, можливо, не вс╕м до
	смаку). Кр╕м того, що ще г╕рше, систему неможливо поновити
	(тобто поновити ╖╖ ядро) записавши зам╕сть старого ядра нове
	на диск. А мр╕яти про те, щоб мати на диску два ядра (йдеться
	не про два р╕зних розд╕ли з р╕зними системами на них, а саме
	про один розд╕л з к╕лькома ядрами, як╕ можна стартувати за
	бажанням). 
	
	В будь-якоому Юн╕кс╕, ( Л╕накс не ╓ виключенням), можливо
	вказати яке саме ядро Ви хочете стартувати. Але оск╕льки
	Л╕наксу д╕сталися в спадщину обмеження, ╕снуюч╕ в св╕т╕ PC,
	доводиться трохи хитрувати, щоб ╖х об╕йти - ╕ вимога мати ядро
	на перших цил╕ндрах ╓ саме такими хитрощами.\end{intnote}.

	Деяк╕ нов╕ш╕ верс╕╖ BIOS'╕в з IDE дисками, фактично, вм╕ють
	поводитися з дисками, що мають б╕льше н╕ж 1024 цил╕ндри. Якщо
	Ви ма╓те таку систему, Ви можете забути про те, що т╕льки що
	прочитали, але якщо Ви не впевнен╕, то поклад╕ть ядро в перш╕
	1024 цил╕ндри.\intnote{Для цього багато ╕ не треба. Дал╕ буде
	йтися про те, що кореневу файлову систему завжди краще мати
	невелику - маючи на н╕й абсолютний м╕н╕мум директор╕й
	необх╕дних для завантаження системи. М╕й особистий досв╕д
	св╕дчить, що самий песим╕стичний прогноз щодо коренево╖
	файлово╖ системи - це максимум 50МБайт (а в б╕льшост╕ випадк╕в
	достатньо 15-20МБайт). Тобто, такий розд╕л достатньо малий ╕
	на будь-якому сучасному диску (╕з величезними цил╕ндрами),
	пом╕стити цей розд╕л першим достатньо для того, щоб бути
	певним, що в╕н повн╕стю лежить в потр╕бних межах. На старих же
	дисках ц╕╓╖ проблеми не ╕сну╓ взагал╕, оск╕льки так╕ диски
	часто мають менше, н╕д 1024 цил╕ндри. Ситуац╕я трохи
	пог╕ршу╓ться, якщо Вам треба грузити ще й Windows з цього
	диску, але це вже ╕нше питання.}

	Кожен розд╕л повинен мати парне число сектор╕в, оск╕льки
	файлова система Л╕накса користу╓ться блоком розм╕ром 1~кБайт,
	тобто двома секторами. Непарна к╕льк╕сть сектор╕в не принесе
	Вам н╕яких прикрощ╕в кр╕м того т╕льки, що останн╕й сектор не
	буде використовуватися, ╕ деяк╕ з верс╕й \cmd{fdisk}
	попередять Вас про це (ну а кр╕м того - це просто непристойно).

	Якщо Вам потр╕бно зм╕нити розм╕р розд╕лу диску, зробити
	практично це можна ╓диним способом - зробивши резервну коп╕ю
	всього, що ╓ на цьому розд╕л╕ (або всього диску, що набагато
	над╕йн╕ше), стерши цей розд╕л, створивши новий ╕ поновивши на
	цьому розд╕л╕ все з резервно╖ коп╕╖. Якщо розм╕р розд╕лу
	зб╕льшу╓ться, можливо Вам потр╕бно буде також в╕дрегулювати
	(╕з створенням резервних коп╕й ╕ в╕дновленням) розм╕ри
	сус╕дн╕х розд╕л╕в також.

	╤ оск╕льки такий процес досить бол╕сний, бажано встановити
	в╕рн╕ розм╕ри розд╕л╕в прямо з першого разу, або ж придбати
	апаратуру для швидкого ╕ безбол╕сного створення резервних
	коп╕й ╕ в╕дновлення. Якщо Ви т╕льки встановлю╓те систему з
	нос╕╖в, як╕ до того ж не вимагають часто╖ зм╕ни (як,
	наприклад, компакт-диски), Ви ма╓те можлив╕сть трохи
	побавитися з р╕зноман╕тними конф╕╜урац╕ями при цьому. Не маючи
	н╕яких власних даних в нов╕й систем╕, прост╕ше зм╕нювати
	розд╕ли по к╕лька раз╕в.

	Для DOS'у ╕сну╓ програма \cmd{fips}, яка розповсюджу╓ться з
	Л╕наксом, за допомогою яко╖ можна зм╕нювати розм╕ри розд╕л╕в
	DOS'у без резервування та в╕дтворення даних, але для ╕нших
	систем це все ще необх╕дно робити.

\subsection{Спец╕альн╕ файли пристро╖в та розд╕ли диску}

	Кожен розд╕л ╕ кожен розширений розд╕л ма╓ св╕й власний
	спец╕альний файл
	пристрою. За домовлен╕стю назви цих файл╕в утворюються
	при╓днанням номера розд╕лу диска п╕сля назви файлу самого
	диску. За домовлен╕стю також перш╕ чотири розд╕ли (з номерами
	1--4) ╓ основними розд╕лами, незалежно в╕д ╖х к╕лькост╕, а
	номери 5--8 зарезервован╕ за лог╕чними розд╕лами, незалежно
	в╕д того, ск╕льки ма╓ться основних розд╕л╕в на диску ╕ в╕д
	того, на якому з основних розд╕л╕в ц╕ лог╕чн╕ розд╕ли
	знаходяться. Наприклад, \fn{/dev/hda1} - це перший основний
	розд╕л на першому IDE диску, а \fn{/dev/sdb7} - трет╕й
	розширений розд╕л на другому SCSI диску. Повний список файл╕в
	пристро╖в наведений в~\cite{device-list}.

\section{Файлов╕ системи}
\label{sec:filesystems}

\subsection{Що таке файлов╕ системи?}

	\defin{Файлова система} - це метод та структура даних, як╕
	використовуються операц╕йною системою для збереження
	╕нформац╕╖ про файли на диску чи розд╕л╕ диску. Тобто, ╕ншими
	словами, - це метод орган╕зац╕╖ збереження файл╕в на диску. Терм╕н
	часто також вжива╓ться як синон╕м до сл╕в "<диск"> або
	"<дисковий розд╕л">, коли мова йде про файли розташован╕ на
	даному диску чи розд╕л╕. Отже, якщо Ви почу╓те "<Я маю дв╕
	файлов╕ системи">, знайте, що при цьому ма╓ться на уваз╕, два
	п╕дрозд╕ли, як╕ служать для запису файл╕в, або у випадку з
	Л╕наксом - це два п╕дрозд╕ли ╕з файловими системами типу ext2
	("<розширена файлова система">, як ╖╖ називають в
	Л╕накс╕). В╕дм╕нност╕ м╕ж диском чи розд╕лом на диску та
	файловою системою, яка на ньому створена сутт╓в╕. Лише деяк╕
	програми (включаючи сюди т╕, як╕ створюють файлов╕ системи)
	можуть працювати безпосередньо з секторами\intnote{В
	англ╕йськ╕й мов╕ разом з ╕менником "<сектор"> в даному випадку
	вжива╓ться прикметник "<raw">(raw disk, raw sector, raw
	partition), який досл╕вно мав би перекладатися як "<сирий">
	або "<неприготований">. Ця терм╕ноло╜╕я в╕дноситься,
	наприклад, до дискового п╕дрозд╕лу без створено╖ на ньому
	файлово╖ системи, або просто до спец╕ального файлу дискового
	п╕дрозд╕лу чи всього диску. Як протилежн╕сть до нього
	використову╓ться "<cooked"> - тобто розд╕л ╕з файловою
	системою на ньому. (анало╜╕чно - cooked device,
	cooked partition, тощо) - тобто "<приготований"> (зварений,
	п╕дсмажений). Досл╕вний переклад укра╖нською п╕сля цього
	виглядав би досить "<ц╕кавим">, але на м╕й погляд - це
	занадто. Тому я, спод╕ваючись на високий ╕нтелектуальний р╕вень
	укра╖нського читача, просто опускаю в таких випадках
	прикметник. Хочу в╕рити, що читач сам може визначити, де йде
	мова про сире ╕ де про варене.} на диску або його
	розд╕л╕. Якщо на цьому диску або розд╕л╕ вже ╕сну╓ файлова
	система, вона може такими програмами бути знищена або серйозно
	пошкоджена. Б╕льш╕сть програм працюють, на в╕дм╕ну в╕д згаданих
	к╕лькох, з файловими системами ╕, отже, не зможуть працювати з
	розд╕лами, як╕ не мають файлово╖ системи на них (або, що
	приблизно те ж саме, - мають файлову систему не того типу, що
	потр╕бен). 

	Перед тим, як використовувати диск або розд╕л як файлову
	систему, його треба ╕н╕ц╕ал╕зувати. При цьому на диск
	запису╓ться деяка ╕нформац╕я для п╕дтримання файлово╖ системи
	у в╕дносному порядку. Цей процес в╕домий як \defin{створення
	файлово╖ системи}.

	Б╕льш╕сть файлових систем Юн╕кс╕в мають дуже схожу загальну
	структуру, але все-таки розходяться в подробицях. Основн╕
	поняття включають \defin{суперблок}\intnote{superblock},
	\defin{inode}\ref{dict:inode}, \defin{блок даних}\intnote{data
	block}, \defin{блок директор╕╖}\intnote{directory block} та
	\defin{блок ссилок}\ref{dict:indirection}. Суперблок м╕стить
	╕нформац╕ю про файлову систему в ц╕лому, таку, наприклад, як
	╖╖ розм╕р (детальна ╕нформац╕я, яка тут мала б знаходиться,
	залежить в╕д конкретного типу файлово╖ системи). В inode
	збер╕га╓ться вся ╕нформац╕я про окремий файл, кр╕м його назви
	\begin{intnote} 
%
%
	Кожен файл ма╓ inode, але не кожен файл ма╓ св╕й \emph{власний}
	inode. Власне, для кращого розм╕ння варто п╕дкреслити, що саме
	inode ╕ ╓ файлом, а та назва, що бачить користувач, ╓
	всього-навсього етикеткою, яка причеплена до inode. Якщо inode
	ма╓ к╕лька етикеток, то кажуть, що м╕ж файлами встановлен╕
	"<жорстк╕ ссилки"> - hard link. Тобто дв╕ р╕зн╕ етикетки
	можуть вказувати на один ╕ той же файл - для користувача це
	вигляда╓ так, н╕би то один файл ма╓ к╕лька назв.

	Сл╕д також в╕дчувати р╕зницю м╕ж жорсткими та м'якими
	(символ╕чними) ссилками (soft link або symbolic link,
	symlink). Якщо жорстка ссилка це не що ╕нше, як просто ╕нша
	назва одного ╕ того ж файлу, то символ╕чна ссилка - це
	спец╕альний вид файлу. Якщо подивитися на символ╕чну ссилку,
	наприклад, командою \cmd{ls -l}, то пом╕тно, що символ╕чна
	ссилка - це файл дуже невеликого розм╕ру, часто 10-14 байт. Що
	ж таке ц╕ байти? Це - просто маршрут до ориг╕налу (як кажуть
	"<батька">) ц╕╓╖ символ╕чно╖ ссилки. 

	Так, наприклад, якщо символ╕чна ссилка була створена такою
	командою, як \cmd{ln -s /usr/X11R6 /usr/X11 }, то файл
	\fn{/usr/X11} буде символ╕чною ссилкою на \fn{/usr/X11R6}, ╕
	його розм╕р буде р╕вно 10 байт - тобто к╕льк╕сть символ╕в у
	\texttt{/usr/X11R6}, разом ╕з '/'.

\verb|#| {\sl ln -s /usr/X11R6 /usr/X11} \\
\verb|#|ls -l \\
\verb|#|total 42\\
\verb|#|lrwxrwxrwx   1 root     root           10 Mar 31 08:22 X11 -> /usr/X11R6/\\
\verb|#| [...]\\

	В╕д звичайних файл╕в (в тому числ╕ ╕ в╕д жорстких ссилок)
	символ╕чн╕ ссилки в╕др╕зняються першим символом в рядку, що
	вказу╓ тип файлу - тобто в тому байт╕ inode, де запису╓ться
	тип файлу, у символ╕чно╖ ссилки записано "<l">.

	\end{intnote}.  Назва файлу запису╓ться в директор╕╖ разом з номером
	inode'у. inode збер╕га╓ номери к╕лькох блок╕в, в яких
	записаний сам файл. Але в inode'╕ достатньо м╕сця т╕льки для
	к╕лькох блок╕в даних, однак, якщо потр╕бно буде б╕льше, для
	ссилок на наступн╕ блоки динам╕чно вид╕ля╓ться б╕льше
	м╕сця. Ц╕ блоки, що вид╕ляються динам╕чно, ╓ непрямими
	блоками. Тобто, сама ╖х назва вказу╓ на те, що перш, н╕ж
	прочитати дан╕ з блоку, потр╕бно знайти, де знаходиться сам
	блок, користуючись ссилкою на нього.

%	\meta this needs rewriting.  
	Як звичайно файлов╕ системи Юн╕кс╕в дозволяють мати файли з
	\defin{"<д╕рками">} (це робиться за допомогою команди
	\cmd{lseek}, краще д╕знатися про яку можна з стор╕нки
	п╕дказки). Д╕рка в файл╕ означа╓, що файлова система просто
	робить вигляд, н╕бито якесь певне м╕сце в файл╕ ма╓ розм╕р
	нуль байт╕в, але жодного дискового простору при цьому не
	резерву╓ться на це в самому файл╕ (тобто файл насправд╕ буде
	використовувати трохи менше дискового простору). Це
	трапля╓ться особливо часто для невеликих дв╕йкових файл╕в,
	б╕бл╕отек для сп╕льного користування в Л╕накс╕, деяких баз
	даних та деяких спец╕альних випадк╕в. (Д╕рки створюються
	записуванням певно╖ спец╕ально╖ величини в блоц╕ ссилок або
	в inode'╕. Ця спец╕альна адреса означа╓, що для блоку даних не
	в╕дводиться простору на диску, тобто в файл╕ - д╕рка.)

	Д╕рки досить корисн╕. На систем╕ автора просте вим╕рювання
	показало, що д╕рки збер╕гають близько 4~МБайт з 200~МБайт
	диску. Щоправда система ма╓ в╕дносно мало програм ╕ не ма╓ баз
	даних. Зас╕б для вим╕рювання д╕рок описаний в
	додатку~\ref{chap:measure-holes}. \begin{intnote}
%
	Наявн╕сть д╕рок в файлах ╕нколи може спричинити деяк╕
	непри╓мнощ╕. Тому треба пам'ятати про те в яких файлах д╕рки
	можуть траплятися ╕ що треба робити, щоб ц╕ д╕рки
	"<обходити">.

	Так, наприклад, одним з найб╕льш розповсюджен╕ших тип╕в
	файл╕в, в яких можуть траплятися д╕рки ╓ файли баз даних
	dbm. Так╕ файли використовуються в базах даних мап
	NIS~\ref{dict:nis} або в базах даних користувач╕в, як╕
	використовуються в \cmd{sendmail} верс╕й 8.x. 

	Через те, ╕нколи виявля╓ться, що сума розм╕р╕в вс╕й файл╕в баз
	даних може бути б╕льшою, н╕ж розм╕р дискового розд╕лу, який
	м╕стить так╕ файли. Якщо в мереж╕ ма╓ться к╕лька сервер╕в NIS,
	то вони найчаст╕ше будуються за принципом - один головний
	сервер (master) ╕ вс╕ ╕нш╕ сервери-п╕длегл╕ (slave). При
	необх╕дност╕ обновити бази даних на п╕длеглих серверах
	використову╓ться команда \cmd{xfer}, яка фактично робить
	коп╕ювання файл╕в баз даних з головного сервера на п╕длегл╕.
	Це ж саме може в принцип╕ робити команда \cmd{rcp}, ╕ якщо
	файли не мають д╕рок, то д╕я обох команд ╕дентична. Але
	команда \cmd{rcp} "<не розум╕╓"> д╕рок ╕ у випадку файл╕в з
	д╕рками використання команди \cmd{rcp} приводить до того, що
	коп╕я виявля╓ться б╕льшою ори╜╕налу ╕ дисковий розд╕л
	п╕длеглого сервера може переповнитися в той час, як на
	головному сервер╕ ще буде повно в╕льного м╕сця.  \end{intnote}

\subsection{Галоп по файловиx системаx}

	Л╕накс п╕дтриму╓ к╕лька файлових систем, серед яких
	найважлив╕шими ╓:
		%
	\begin{description}
	\item[minix]

		Найстар╕ша з ус╕х ╕ вважа╓ться найб╕льш
		заслуговуючою на дов╕ру. В той же час, вона досить
		обмежена за можливостями (в╕дсутн╕ деяк╕ часов╕
		в╕дбитки\intnote{time stamps}, довжина назви файлу
		обмежена 30-ма л╕терами , може мати максимум 64~МБайти
		на файлову систему).

	\item[xia]

		Видозм╕нена верс╕я файлово╖ системи minix, яка
		розширила меж╕ довжин назви файлу та розм╕р файлово╖
		системи, але не додала нових можливостей до
		системи. Це - не дуже популярна файлова система, але,
		як  пов╕домлялося, працю╓ досить гарно. 

	\item[ext2]

		Найб╕льш багата можливостями р╕дна файлова система
		Л╕накса, на даний момент - найб╕льш вживана, була
		спроектована таким чином, щоб ╖╖ легко можна було
		розширювати та доповнювати новими можливостями, тобто
		нов╕ верс╕╖ коду файлових систем не будуть вимагати
		перебудови ╕снуючих файлових систем.

	\item[ext]

		Стар╕ша верс╕я - попередниця \texttt{ext2}, яка була
		спроектована без думок про розширення. ╥╖ практично
		вже нема╓ в нових системах, ╕ т╕ хто мав ╖╖ в старих,
		вже зам╕нили ╖╖ новою верс╕╓ю.

	\end{description}
		%
	Додатково до цього, ╕сну╓ п╕дтримка для деяких "<╕ноземних">
	файлових систем, що робить прост╕шим обм╕н файлами з ╕ншими
	системами. Вс╕ ц╕ ╕ноземн╕ системи працюють практично так
	само, як ╕ р╕дн╕ файлов╕ системи Л╕накса, але можливо вони не
	мають тих чи ╕нших можливостей, як╕ присутн╕ в Юн╕ксах, або
	мають деяк╕ см╕шн╕ обмеження або ще що.
		%
	\begin{description}
	\item[msdos]

		Сум╕сн╕сть з DOS (а також з OS/2 та Windows NT) -
		файлов╕ системи FAT. 

	\item[umsdos]
		Розширення файлово╖ системи \texttt{msdos} для Л╕накса
		- для вживання довгих назв файл╕в, з можлив╕стю
		присво╓ння власник╕в файлам,
		дозвол╕в, ссилок та файл╕в пристро╖в. Це розширення
		дозволя╓ користуватися звичайною файловою системою
		\texttt{msdos}, так як н╕бито це - файлова система
		Л╕накс, ╕ таким чином в╕дпада╓ необх╕дн╕сть
		користуватися спец╕альною системою для Л╕накса при
		наявност╕ комп'ютера з встановленим DOS'ом.

	\item[iso9660] Стандартна файлова система компакт-диск╕в, ма╓
		популярне розширення "<Рок Р╕дж">, яке дозволя╓
		вживати довг╕ назви файл╕в. Розширення Рок Р╕дж при
		необх╕дност╕ п╕дключа╓ться автоматично.

	\item[nfs]
		
		Файлова система мереж╕ \intnote{networked file system
- NFS} - файлова система, яка дозволя╓ сп╕льно на багатьох комп'ютерах
в мереж╕ користуватися файлами ╕ дозволя╓ простий доступ до них з
будь-якого з комп'ютер╕в мереж╕.
			
	\item[hpfs]
		Файлова система OS/2.
	\item[sysv]
		Файлов╕ системи SystemV/386, Coherent та Xenix.
	\end{description}
	\begin{intnote}До цього можна додати деяк╕ додатков╕ системи не
		згадан╕ в ори╜╕нал╕.
		\begin{description}
		\item[vfat]
		Файлова система застосовувана в Windows 95 -
		розширення файлово╖ системи DOS, яке дозволя╓
		користуватися довгими назвами файл╕в. 

		\item[hfs]

		"<╤╓рарх╕чна файлова система"> (hierarchical
		file system), яка застосову╓ться в операц╕йн╕й систем╕
		MacOS на Мак╕нтошах. Ця система може мати так╕ два
		застосування - для читання дискет записаних на
		Мак╕нтош╕, та (в по╓днанн╕ з реал╕зац╕╓ю протоколу
		р╕дно╖ Мак╕нтош╕всько╖ мереж╕ AppleTalk) для
		побудови файл сервера для мереж╕ Mac'╕в (Л╕накс
		дозволя╓, наприклад, змонтувати Мак╕нтошевський
		компакт-диск та експортувати його для вс╕╓╖ мереж╕
		Mac'╕в).

		\item[ufs]
		Файлова система, що застосову╓ться в SunOS та
		Solaris. В терм╕ноло╜╕╖ SunOS - це файлова система
		типу "<4.2">, а в Solaris'╕ вона ж носить назву
		"<ufs">. Дуже важлива файлова система особливо для
		Sparc Linux'а, оскл╕льки дозволя╓ сп╕льно
		користуватися файловими системами SunOS/Solaris ╕
		Sparc Л╕накса.
	\end{description}
	\end{intnote}
		%

	Виб╕р файлово╖ системи залежить в╕д ситуац╕╖. Якщо Ви хочете
	 мати доступ до одних ╕ тих же файл╕в з Л╕накса та з яко╖сь
	 ╕ншо╖ операц╕йно╖ системи (встановлено╖ на цьому ж
	 комп'ютер╕), то повинна використовуватися файлова система
	 саме ц╕╓╖ операц╕йно╖ системи. Якщо ж Ви ма╓те в╕льний виб╕р,
	 тод╕ найкращим вибором буде файлова система ext2, оск╕льки
	 вона ма╓ вс╕ необх╕дн╕ функц╕╖ ╕ достатньо швидка.

	Кр╕м згаданих вище файлових систем в Л╕накс╕ ╓ також файлова
	система \texttt{proc}, змонтована в директор╕╖ \fn{proc}, яка
	насправд╕ не ╓ файловою системою, хоча ╕ дуже на не╖
	схожа. Файлова система \texttt{proc} полегшу╓ доступ структур
	даних всередин╕ ядра ╕ процес╕в (зв╕дки ╕ назва). Вона пода╓
	користувачев╕ ц╕ структури у вигляд╕ файлово╖ системи, ╕ до
	даних в такому вигляд╕ можна застосовувати звичайн╕ засоби для
	роботи з файлами. Наприклад, для того, щоб отримати список
	вс╕х процес╕в в систем╕ можна скористуватися командою

	%
	\begin{quote}\tt
\verb|$| {\sl ls -l /proc} \\
\verb|total 0| \\
\verb|dr-xr-xr-x   4 root     root            0 Jan 31 20:37 1| \\
\verb|dr-xr-xr-x   4 liw      users           0 Jan 31 20:37 63| \\
\verb|dr-xr-xr-x   4 liw      users           0 Jan 31 20:37 94| \\
\verb|dr-xr-xr-x   4 liw      users           0 Jan 31 20:37 95| \\
\verb|dr-xr-xr-x   4 root     users           0 Jan 31 20:37 98| \\
\verb|dr-xr-xr-x   4 liw      users           0 Jan 31 20:37 99| \\
\verb|-r--r--r--   1 root     root            0 Jan 31 20:37 devices| \\
\verb|-r--r--r--   1 root     root            0 Jan 31 20:37 dma| \\
\verb|-r--r--r--   1 root     root            0 Jan 31 20:37 filesystems| \\
\verb|-r--r--r--   1 root     root            0 Jan 31 20:37 interrupts| \\
\verb|-r--------   1 root     root      8654848 Jan 31 20:37 kcore| \\
\verb|-r--r--r--   1 root     root            0 Jan 31 11:50 kmsg| \\
\verb|-r--r--r--   1 root     root            0 Jan 31 20:37 ksyms| \\
\verb|-r--r--r--   1 root     root            0 Jan 31 11:51 loadavg| \\
\verb|-r--r--r--   1 root     root            0 Jan 31 20:37 meminfo| \\
\verb|-r--r--r--   1 root     root            0 Jan 31 20:37 modules| \\
\verb|dr-xr-xr-x   2 root     root            0 Jan 31 20:37 net| \\
\verb|dr-xr-xr-x   4 root     root            0 Jan 31 20:37 self| \\
\verb|-r--r--r--   1 root     root            0 Jan 31 20:37 stat| \\
\verb|-r--r--r--   1 root     root            0 Jan 31 20:37 uptime| \\
\verb|-r--r--r--   1 root     root            0 Jan 31 20:37 version| \\
\verb|$|
		\rm\end{quote}
		%

	(Кр╕м наведених тут буде ще к╕лька додаткових файл╕в, як╕ не
	мають в╕дпов╕дних процес╕в. Приклад, наведений тут, трохи
	скорочений пор╕вняно з реальною ситуац╕╓ю.)

	Хоча \texttt{/proc} ╕ назива╓ться файловою системою, жодна ╖╖
	частина нав╕ть ╕ не торка╓ться диску. Вона вся ╕сну╓ т╕льки
	в уяв╕ ядра. Коли будь-хто намага╓ться звернутися до будь-яко╖
	з частин файлово╖ системи \texttt{proc}, ядро пода╓ ╖╖ так,
	н╕би то вона справд╕ ╕сну╓ десь. Отже, нав╕ть якщо Ви власними
	очима бачите тут багато-мегабайтний файл \fn{/proc/kcore}, в╕н
	не займа╓ жодного байту пам'ят╕ н╕ на диску, н╕ в пам'ят╕ (до
	того часу, поки Ви не почнете його коп╕ювати куди-небудь).

\subsection{Якою файловою системою користуватися?}

	В б╕льшост╕ випадк╕в нема╓ жодного сенсу в користуванн╕
	багатьма файловими системами одночасно. Зараз найб╕льш
	популярною ╓ ext2fs, ╕, напевно тому, краще всього
	користуватися нею.  В залежност╕ в╕д конкретних вимог до
	структури, швидкост╕, над╕йност╕, сум╕сност╕, тощо, сл╕д
	розлядати також т╕ чи ╕нш╕ системи поза ext2fs. Але к╕нцеве
	конкретне р╕шення завжди залежить в╕д конкретних умов.

\subsection{Створення файлово╖ системи}\label{sec:mkfs}

	Файлов╕ системи створюются (або "<╕н╕ц╕ал╕зуються">) за
	допомогою команди \cmd{mkfs}. Насправд╕ ж, для кожно╖ файлово╖
	системи ╕сну╓ своя власна команда. Команда \cmd{mkfs}
	всього-навсього фасад до ц╕ло╖ групи команд, ╕ для створення то╖
	або ╕ншо╖ файлово╖ системи, застосову╓ться в╕дпов╕дна ╖й
	команда. Тип файлово╖ системи, яку треба створити, зада╓ться за 
	допомогою параметру \texttt{-t тип\_файлово╖\_системи}
	команд╕ \cmd{mkfs}.
	
	Програми, як╕ викликаються командою \cmd{mkfs}, мають р╕зн╕
	параметри. Загальн╕ (╕ найб╕льш важлив╕) параметри наведен╕
	нижче, але конкретн╕ш╕ дан╕ можна завжди в╕дшукати в стор╕нц╕
	п╕дказки по конкретн╕й команд╕.

	\begin{quote}
	\begin{description}
	\item[{\tt -t} {\it тип\_файлово╖\_системи}] Вибер╕ть тип
	файлово╖ системи.
	\item[{\tt -c}] Шукати зб╕йн╕ блоки та поновити ╖х список.
	\item[{\tt -l} {\it назва\_файлу}] Прочитати попередн╕й список
	зб╕йних блок╕в з файлу  {\it назва\_файлу}.
	\end{description}
	\end{quote}
	%
	Щоб створити на дискет╕ файлову систему типу ext2, потр╕бно
	виконати так╕ команди:
		%
		\begin{quote}\tt
\verb|$| {\sl fdformat -n /dev/fd0H1440 } \\
\verb|Double-sided, 80 tracks, 18 sec/track. Total capacity 1440 kB.| \\
\verb|Formatting ... done| \\
\verb|$| {\sl badblocks /dev/fd0H1440 1440 $>$ bad-blocks} \\
\verb|$| {\sl mkfs -t ext2 -l bad-blocks /dev/fd0H1440} \\
\verb|mke2fs 0.5a, 5-Apr-94 for EXT2 FS 0.5, 94/03/10| \\
\verb|360 inodes, 1440 blocks| \\
\verb|72 blocks (5.00%) reserved for the super user| \\
\verb|First data block=1| \\
\verb|Block size=1024 (log=0)| \\
\verb|Fragment size=1024 (log=0)| \\
\verb|1 block group| \\
\verb|8192 blocks per group, 8192 fragments per group| \\
\verb|360 inodes per group| \\
\verb||\\
\verb|Writing inode tables: done     | \\
\verb|Writing superblocks and filesystem accounting information: done| \\
\verb|$|
		\rm\end{quote}
		%

	Спершу дискета формату╓ться (параметр \texttt{-n} забороня╓
	перев╕рку дискети на зб╕йн╕ блоки). П╕сля цього зб╕йн╕ блоки
	шукаються командою \cmd{badblocks}, результати роботи яко╖
	в╕дправляються в файл. ╤, нарешт╕, створю╓ться файлова
	система, ╕ при цьому використову╓ться список зб╕йних блок╕в,
	створений командою \cmd{badblocks}.

	Зам╕сть команди \cmd{badblocks} можна скористуватися
	параметром  {\tt -c}, при цьому в╕дпада╓ необх╕дн╕сть в
	додатковому файл╕. Таке використання команди показано в
	наступному приклад╕.
		%
		\begin{quote}\tt
\verb|$| {\sl mkfs -t ext2 -c /dev/fd0H1440} \\
\verb|mke2fs 0.5a, 5-Apr-94 for EXT2 FS 0.5, 94/03/10| \\
\verb|360 inodes, 1440 blocks| \\
\verb|72 blocks (5.00%) reserved for the super user| \\
\verb|First data block=1| \\
\verb|Block size=1024 (log=0)| \\
\verb|Fragment size=1024 (log=0)| \\
\verb|1 block group| \\
\verb|8192 blocks per group, 8192 fragments per group| \\
\verb|360 inodes per group| \\
\verb| | \\
\verb|Checking for bad blocks (read-only test): done| \\
\verb|Writing inode tables: done     | \\
\verb|Writing superblocks and filesystem accounting information: done| \\
\verb|$|
		\rm\end{quote}
		%
	Параметром {\tt -c} зручн╕ше користуватися, н╕ж командою
	\cmd{badblocks} ╕ додактковим файлом, але для перев╕рки
	файлово╖ системи п╕сля ╖╖ створення краще все-таки вживати
	\cmd{badblocks}.
	
	Процес створення файлово╖ системи на жорсткому диску
	в╕др╕зня╓ться в╕д процесу для дискет т╕льки тим, що при
	в╕дпада╓ крок форматування. 

\subsection{Монтування та розмонтування}\label{subsec:mount}

	Перед тим, як користуватися файловою системою, ╖╖ треба
	\defin{змонтувати}. П╕сля монтування, для того, щоб
	п╕дтримувати в робочому порядку, система перейма╓ на себе
	обов'язки по контролю файлово╖ системи. Оск╕льки вс╕ файли в
	Юн╕кс╕ розташован╕ в ╓диному дерев╕, п╕сля монтування
	виявля╓ться, що все, що знаходилось до монтування в окрем╕й
	файлов╕й систем╕, ста╓ складовою директор╕╓ю в цьому дерев╕.

	Наприклад, рисунок~\ref{fig:hd-mount-root} показу╓ три окрем╕
	файлов╕ системи, кожна з╕ сво╖м власним коренем (кореневою
	директор╕╓ю). П╕сля того, як дв╕ останн╕ файлов╕ системи
	змонтован╕ в точках \fn{/home} та \fn{/usr} першо╖ файлово╖
	системи, утворю╓ться ╓дине дерево директор╕й показане на
	рисунку~\ref{fig:hd-mount-all}.  

		\begin{figure}[thb]
		\begin{center}
		\includegraphics{disks/hd-mount-separate.ps}
		\end{center}
		\caption{Три окрем╕ файлов╕ системи.}
		\label{fig:hd-mount-root}
		\end{figure}

		\begin{figure}[thb]
		\begin{center}
		\includegraphics{disks/hd-mount-mounted.ps}
		\end{center}
		\caption{\fn{/home} та \fn{/usr} змонтовано.}
		\label{fig:hd-mount-all}
		\end{figure}

	Операц╕╖ монтування виконуються наступними командами:
		%
		\begin{quote}\tt
\verb|$| {\sl mount /dev/hda2 /home} \\
\verb|$| {\sl mount /dev/hda3 /usr} \\
\verb|$| \\
\verb|$| \\
		\rm\end{quote}
		%

	Команд╕ \cmd{mount} потр╕бно давати два ар╜ументи. Перший з
	них - це спец╕альний файл пристрою, який в╕дпов╕да╓ диску чи
	п╕дрозд╕лу з файловою системою. Другий - директор╕я, в як╕й
	потр╕бно змонтвуати дану файлову систему. П╕сля того, як
	виконано ц╕ дв╕ команди, все, що знаходиться в змонтованих
	фалових системах, буде виглядати як склад директор╕й
	\fn{/home} та \fn{/usr}. Кажуть, що "<\fn{/dev/hda2}
	\defin{змонтовано} на \fn{/home}">, ╕, анало╜╕чно для
	\fn{/usr}. Щоб подивитися, що знаходиться в т╕й, чи ╕нш╕й
	файлов╕й систем╕ (п╕сля ╖╖ монтування), сл╕д дивитися, що
	знаходиться в т╕й директор╕╖, на як╕й ця файлова система
	змонтована, так, як н╕би-то це - звичайна директор╕я.
	В╕дм╕тьте р╕зницю м╕ж спец╕альним файлом пристрою
	(\fn{/dev/hda2} та директор╕╓ю, на яку його змонтовано
	(\fn{/home}. Перший з них да╓ доступ до "<сирого"> диску (або
	розд╕лу), в той час, як друга - опису╓ доступ до "<готово╖">
	директор╕╖ на диску. Директор╕ю, в як╕й проводиться монтування
	файлово╖ системи, називають \defin{точкою монтування}.

	Л╕наксом, як уже в╕дм╕чалося, п╕дтримуються файлов╕ системи багатьох
	тип╕в. Команда \cmd{mount} намага╓ться вгадати тип файлово╖ системи,
	яку вона монту╓. Але кр╕м цього можна також користуватися
	параметром {\tt -t \sl тип\_файлово╖\_системи}, щоб явно вказати
	тип. ╤нколи це необх╕дно, бо бува╓, що шлях здогадок
	п╕дводить. Наприклад, щоб змонтувати файлову систему DOS на
	дискет╕, потр╕бно виконати команду:
		%
		\begin{quote}\tt
\verb|$| {\sl mount -t msdos /dev/fd0 /floppy} \\
\verb|$|
		\rm\end{quote}
		%

	В╕д директор╕╖, на вершин╕ яко╖ монту╓ться файлова система, не
	вимага╓ться, щоб вона була пустою, але необх╕дно, щоб вона
	╕снувала. Однак, вс╕ файли, як╕ ╕снували в ц╕й директор╕╖ до
	монтування будуть недоступними п╕сля того, як файлова система
	змонтована. (Будь як╕ файли, в╕дкрит╕ на час монтування будуть
	залишатися доступними, так само, як ╕ файли в дан╕й
	директор╕╖, як╕ мають жорстк╕ ссилки на себе з ╕нших частин
	файлово╖ системи, можуть бути доступними з використанням цих
	╕нших ╕мен.) Цим не завда╓ться жодно╖ шкоди, ╕ ╕нколи такий
	ефект можна використати на користь. Наприклад, уяв╕мо соб╕, що
	\fn{/tmp} та \fn{/var/tmp} ╓ синон╕мами, та \fn{/tmp} ╓
	символ╕чною ссилкою на \fn{/var/tmp}. П╕д час старту системи,
	коли файлова система \fn{/var} ще не змонтована, для
	тимчасових файл╕в використову╓ться директор╕я \fn{/var/tmp},
	яка знаходиться на коренев╕й файлов╕й систем╕. П╕сля того, як
	\fn{/var} змонтована, директор╕я \fn{/var/tmp} в коренев╕й
	директор╕╖ робиться недоступною, ╕ зам╕сть не╖
	використову╓ться змонтована на ╖╖ вершин╕ файлова
	система. Якби директор╕я \fn{/var/tmp} не ╕снувала, то було б
	неможливо користуватися тимчасовими файлами до того, як
	змонтована \fn{/var}.

	Якщо Ви не збира╓тесь записувати н╕чого в файлову систему, яку
	монту╓те, Ви можете скористуватися параметром {\tt -r} для
	того, щоб змонтувати цю файлову систему в режим╕ \defin{т╕льки
	читання}\intnote{readonly}. Отримавши цей параметр, ядро
	зупинить будь-яку спробу записати що-небуть в файлову систему
	╕ ядро не буде зм╕нювати час доступу\intnote{file access time}
	до inode'╕в файл╕в в дан╕й файлов╕й систем╕. Монтування в
	режим╕ "<т╕льки читання"> необх╕дне для нос╕╖в, на як╕ запис
	неможливий, таких, наприклад, як компакт-диски\begin{intnote}П╕сля
	роботи з Л╕наксом спроба змонтувати компакт в SunOS або в
	Solaris'╕ може спочатку збити системного адм╕н╕стратора з
	пантелику. В Л╕накс╕, якщо Ви намага╓теся змонтувати
	компакт-диск, не вказавши параметра {\tt -r}, то \cmd{mount}
	т╕льки видасть попереження, але диск все-таки змонту╓. Але в
	SunOS чи Solaris'╕ Ви по-перше, отрима╓те попередження, а
	по-друге, повинн╕ будете повторити монтування все-таки з
	використанням цього параметра, бо без нього файлова система не
	змонту╓ться. Додайте до цього ще те, що назви одних ╕ тих-же
	файлових систем в╕др╕зняються в р╕зних системах
	(\texttt{iso9660} в Л╕накс╕ ╕ \texttt{hsfs} в SunOS/Solaris),
	╕ зрозум╕╓те насолодження в╕д користування к╕лькома Юн╕ксами
	в╕дразу.\end{intnote}.

	Уважний читач мабуть уже в╕дм╕тив одну головоломку, а саме: як
	же монту╓ться "<сама перша"> файлова система - та, яка
	назива╓ться \defin{кореневою файловою системою}\intnote{root
	filesystem}, бо вона м╕стить кореневу директор╕ю. Звичайно ж,
	╕з зрозум╕лих причин, цю файлову систему не можна змонтувати
	на вершин╕ ╕ншо╖. В╕дпов╕дь в цьому випадку дуже проста - це
	звичайно ж фокус.\footnote{Про це можна дов╕датися досл╕дивши
	вих╕дн╕ тексти ядра або Пос╕бник по програмуванню
	ядра}\intnote{Kernel Hackers' Guide}. Коренева файлова система
	чар╕вним способом виявля╓ться змонтованою при запуску системи,
	╕ можна завжди розраховувати на те, що вона змонтована - якщо
	неможливо змонтувати кореневу файлову систему, система просто
	не завантажиться. Назва то╖ файлово╖ системи, яка маг╕чно
	монту╓ться як коренева, або комп╕лю╓ться безпосередньо в саме
	ядро, або встановлю╓ться за допомогою LILO чи
	\cmd{rdev}\intnote{Л╕накс у в╕дношенн╕ встановлення коренево╖
	файлово╖ системи ╓ набагато гнучк╕шим, н╕ж так╕ системи, як
	SunOS та Solaris. У в╕дношенн╕ монтування кореня SunOS сто╖ть
	на найнижчому р╕вн╕, тобто його гнучк╕сть практично р╕вна
	нулю. Кор╕нь завжди ма╓ бути на першому п╕дрозд╕л╕ диску - це
	скомп╕льовано прямо в ядро. Якщо ядро не може знайти кор╕нь на
	першому розд╕л╕, процес старту спиниться ╕ система буде питати
	про альтернативний кор╕нь (те ж стосу╓ться ╕ своп-розд╕лу на
	диску, який завжди ма╓ бути другим розд╕лом - теж
	"<закомп╕льовано"> в ядро. На в╕дм╕ну в╕д Л╕накса, SunOS не може
	працювати без своп-простору ╕ не знайшовши потр╕бного розд╕лу,
	просто не завантажиться). Тобто в результат╕, запитавши про
	кор╕нь, система завантажиться все-таки в сякий-такий робочий
	стан, але сама перегрузитися вже не зможе. В Solaris'╕ можна
	вказати розд╕л коренево╖ системи, зробивши запис в файл╕
	\texttt{/etc/system}, але вказати альтернативний кор╕нь п╕д
	час старту системи можливо т╕льки, якщо Ви ма╓те альтернативний
	файл \texttt{/etc/system}.}.

	При старт╕ системи коренева система завжди монту╓ться спочатку
	в режим╕ "<т╕льки читання">. П╕зн╕ше ╕з стартових скрипт╕в
	запуска╓ться \cmd{fsck} для перев╕рки ц╕л╕сност╕ файлово╖
	системи, ╕ пот╕м файлова система
	\defin{перемотову╓ться}\intnote{re-mount} в режим╕ дозволу
	запису. Загалом команда \cmd{fsck} не повинна виконуватися на
	змонтованих файлових системах, оск╕льки будь-як╕ зм╕ни до
	файлово╖ системи, над якою вона викону╓ться, {\em викличуть}
	велик╕ проблеми. Але, оск╕льки коренева система в даному
	випадку змонтована з доступом т╕льки на читання, \cmd{fsck}
	може коригувати потр╕бн╕ д╕лянки без проблем, ╕ операц╕я
	перемонтування запише вс╕ потр╕бн╕ зм╕ни з пам'ят╕ на диск.

	В багатьох системах при старт╕ потр╕бно монтувати також ╕нш╕
	файлов╕ системи (кр╕м коренево╖ та своп). Вс╕ вони описуються
	в файл╕ \fn{/etc/fstab}\begin{intnote} або \fn{/etc/vfstab} у
	випадку ╕з Solaris'ом\end{intnote}. Подробиц╕ про формат файлу ╓ в
	стор╕нц╕ п╕дказки \man{fstab}. Те, як конкретно додатков╕
	файлов╕ системи монтуються залежить в╕д багатьох фактор╕в, ╕
	це може конф╕╜урувати кожен окремий системний адм╕н╕стратор
	так, як це потр╕бно. Коли розд╕л про процес старту системи
	буде зак╕нчено, в ньому можна буде це прочитати.

	Якщо файлова система б╕льше не потр╕бна, ╖╖ можна розмонтувати
	командою \cmd{umount}\footnote{Звичайно ж це повинна була б
	бути команда \cmd{unmount}, але л╕тера {\tt n} м╕стично зникла
	десь в середин╕ 70-х ╕ вже б╕льше не з'являлася. Будь-ласка,
	поверн╕ть ╖╖ в Bell Labs, NJ, якщо Ви ╖╖ коли-небудь
	знайдете.}. Для \cmd{umount} потр╕бен один параметр - або
	точка монтування файлово╖ системи, або ╖╖ спец╕альний
	файл. Наприклад, щоб розмотувати директор╕╖, змонтован╕ в
	попередньому приклад╕, потр╕бно виконати команди:
		%
		\begin{quote}\tt
\verb|$| {\sl umount /dev/hda2 } \\
\verb|$| {\sl umount /usr} \\
\verb|$| 
\verb|$| 
		\rm\end{quote}
		%

	Подальш╕ в╕домост╕ про команду див╕ться в стор╕нц╕ п╕дказки по
	н╕й. Не забудьте, що завжди потр╕бно розмонтовувати змонтовану
	дискету. {\em Не витягуйте просто так дискету з дисководу!}
	Через кешування диску в пам'ят╕, дан╕ можуть справд╕
	записуватися на диск багато п╕зн╕ше ╕ не обов'язково записан╕
	на диск, якщо його ще не розмонтовано \intnote{Операц╕я
	розмонтування гаранту╓, що дан╕ записуються з кешу на ф╕зичн╕
	нос╕╖.}. Отже, якщо Ви витягнете дискету зарано - отрима╓те
	см╕ття зам╕сть даних. Якщо Ви т╕льки читали з дискети, то,
	можливо н╕чого страшного не трапиться, але, якщо записали щось
	(нав╕ть випадково), результатом може бути катастрофа.

	Для монтування та розмонтовування файлових систем потр╕бно
	мати прив╕ле╖ супер-користувача, тобто т╕льки користувач
	\fn{root} може це робити. Причиною цього ╓ те, що, якщо
	будь-хто може монтувати чи розмонтовувати, скаж╕мо дискету на
	будь-як╕й директор╕╖, то, в цьому випадку було б дуже просто
	створити, наприклад, Троянського коня замаскованого п╕д
	\cmd{/bin/sh}, або ╕ншу часто вживану програму. Однак,
	звичайним користувачам ╕нколи треба монтувати дискети, ╕ для
	цього ╕сну╓ к╕лька способ╕в:
		%
	\begin{itemize}

	\item Дати користувачев╕ пароль \fn{root}'а. Звичайно ж це
		найг╕рше р╕шення з точки зору безпеки, але ╕
		найпрост╕ше. Воно спрацьову╓ в тих випадках, коли
		нема╓ необх╕дност╕ турбуватися про безпеку, тобто
		годиться на багатьох персональних системах не
		п╕дключених до мереж╕.

	\item Скористуватися програмою типу \cmd{sudo} щоб дозволити
		користувачам користування програмою \cmd{mount}. Це
		все ще не ╕деальне р╕шення з точки зору безпеки, але
		все-таки не да╓ користувачам безпосереднього доступу
		до паролю \fn{root}'а\footnote{Вимага╓ подумати к╕лька
		секунд.}.

	\item Рекомендувати користувачам вживати пакет програм
		\cmd{mtools}, для оперування файлами DOS без
		монтування файлових систем. Цей пакет - дуже зручна штука,
		якщо все, що потр╕бно, це коп╕ювати файли з DOS╕вських
		дискет ╕ назад, але страшенно незручний в ус╕х ╕нших
		випадках.

	\item Перечислити пристро╖ дисковод╕в разом з в╕дпов╕дними
		параметрами для монтування в файл╕ \fn{/etc/fstab}.
	\end{itemize}
		%
	Для реал╕зац╕╖ останнього вар╕анту треба додати до
	\fn{/etc/fstab} приблизно такий рядок:
		%
		\begin{quote}\tt
/dev/fd0            /floppy      msdos   user,noauto      0     0
		\rm\end{quote}
		%

	Стовпчики в рядку так╕: пристр╕й, який треба змонтувати,
	директор╕я, в як╕й потр╕бно монтувати файлову систему, тип
	файлово╖ системи, параметри, частота створення резервних коп╕й
	(використову╓ться командою \cmd{dump}), та номер проходу для
	\cmd{fsck} (Цей параметр служить для того, щоб встановити
	порядок, в якому команда \cmd{fsck} повинна перев╕ряти файлов╕
	ситеми при старт╕ системи. 0 означа╓, що перев╕рка не
	потр╕бна).

	Параметр \texttt{noauto} запоб╕га╓ монтуванню дано╖ файлово╖
	системи при старт╕ системи (тобто команда \cmd{mount -a} не
	змонту╓ цю файлову систему). Параметр \texttt{user} дозволя╓
	монтувати цю файлову систему будь-якому користувачев╕, ╕, (з
	м╕ркувань безпеки) забороня╓ виконання будь-яких програм (як
	нормальних, так ╕ з встановленим setuid) та використання
	будь-яких спец╕альних файл╕в пристро╖в ╕з змонтовано╖ таким
	чином файлово╖ системи.\begin{intnote}В╕дм╕нност╕ SunOS/Solaris в
	даному випадку полягають в тому, що параметр \texttt{user}
	в╕дсутн╕й в обох цих системах. Тобто монтування та
	розмонтування файлових систем дозволено \emph{ т╕льки}
	системному адм╕н╕стратору - \fn{root}'у. Але кр╕м описаних
	способ╕в ╓ ще деяк╕, на яких ми зупинимося трохи дал╕ по
	тексту, ╕ як виявля╓ться не все ще втрачено, нав╕ть, якщо Ви
	адм╕н╕стру╓те SunOS/Solaris.\end{intnote} Якщо такий рядок включено в файл
	\fn{/etc/fstab}, то будь-який користувач може змонтувати
	дискету виконавши команду:
		%
		\begin{quote}\tt
\verb|$| {\sl mount /floppy} \\
\verb|$|
		\rm\end{quote}
		%
	Дискету можна (╕, звичайно ж, потр╕бно) розмонтовувати
	в╕дпов╕дною командою \cmd{umount}.

	\begin{intnote}╢ деяк╕ нюанси при монтуванн╕ файлово╖ системи,
	вказано╖ в \fn{/etc/fstab}. Саме головне при цьому - команда
	\cmd{mount} \emph{повинна} мати т╕льки один параметр - або
	╕м'я спец╕ального файлу пристрою, або точку монтування
	файлово╖ системи. Т╕льки при ц╕й умов╕ \cmd{mount} загляне в
	\fn{/etc/fstab} для того, щоб знайти там ╕нш╕ необх╕дн╕
	параметри. Якщо при монтуванн╕ Ви скориста╓тесь стандартною
	формою команди \cmd{mount спец\_файл точка\_монтування}, то
	команда не буде ссилатися на \fn{/etc/fstab}, а намагатиметься
	змонтувати файлову систему безпосередньо, ╕, оск╕льки Ви - не
	\texttt{root}, видасть помилку: 
	% 
	\begin{quote}\tt
\verb|$| mount : only root can do that \\
\verb|$| 
	\rm\end{quote}
		%
\end{intnote}
	
	Якщо Вам потр╕бно забезпечити можлив╕сть монтування к╕лькох
	тип╕в дискет, Ви повинн╕ забезпечити також ╕ в╕дпов╕дн╕ точки
	монтування для вс╕х них ╕ в╕дпов╕дн╕ рядки для кожного типу в
	\fn{/etc/fstab}. Параметри можуть бути р╕зними для них
	вс╕х. Наприклад, щоб дати доступ до обох файлових систем -
	MS-DOS та ext2 на дискетах, Вам потр╕бно мати так╕ рядки в
	\fn{/etc/fstab}:

		%
		\begin{quote}
		\small
		\begin{verbatim}
/dev/fd0    /dosfloppy    msdos   user,noauto  0  0
/dev/fd0    /ext2floppy   ext2    user,noauto  0  0
		\end{verbatim}
		\end{quote}
		%

	Для файлових систем MS-DOS (не т╕льки дискети, а взагал╕ - вс╕
	з них), було б бажано обмежети доступ використанням
	\texttt{uid} чи \texttt{gid} та параметром \cmd{umask}, як╕ в
	подробицях описан╕ в стор╕нц╕ п╕дказки \man{mount}. Якщо Ви не
	надто безпечн╕, то монтування файлово╖ системи MS-DOS да╓ (як
	м╕н╕мум) доступ на читання для будь-кого, що взагал╕-то не
	бажано. 
	
\subsection{Перев╕рка ц╕л╕сност╕ файлових систем за допомогою
	\cmd{fsck}}

	Файлов╕ системи - дуже складн╕ створ╕ння, ╕ тому, в деякому
	сенс╕, вони схильн╕ до помилок. Ц╕л╕сн╕сть файлово╖ системи чи
	наявн╕сть в н╕й помилок можна перев╕рити за допомогою команди
	\cmd{fsck}. Команд╕ можна вказати, що вона повинна виправляти
	вс╕ незначн╕ помилки, як╕ вона в╕дшука╓, ╕ попереджати
	користувача, якщо трапляються так╕ з них, як╕ не можна
	виправити. На щастя, б╕бл╕отеки вживан╕ для файлових систем
	вже в╕длагоджен╕ досить добре, ╕ проблеми з ними трапляються
	досить р╕дко (або ╖х взагал╕ не бува╓). Збо╖ в файлових
	системах найчаст╕ше трапляються через перебо╖ в
	електропостачанн╕, збо╖ в "<зал╕з╕"> чи через помилки
	оператор╕в, як, наприклад, не вимкнена за правилами система.

	Б╕льш╕сть систем виконують \cmd{fsck} автоматино при старт╕
	системи, так, що б╕льш╕сть помилок знаходяться (╕, дай Боже,
	виправляються) до того, як система почина╓
	використовуватися. Використання з╕псовано╖ файлово╖ системи
	приводить до того, що погане ста╓ ще г╕ршим: якщо структури
	даних файлово╖ системи з╕псован╕, використання цих структур
	може т╕льки зробити ╖х ще г╕ршими, що приведе до ще б╕льших
	втрат даних. Але, з ╕ншого боку, повна перев╕рка файлово╖
	системи на великих файлових системах за допомогою \cmd{fsck}
	може займати досить довгий час. ╤, через те, що помилки
	практично н╕коли не трапляються при корректному вимкненн╕
	системи, для того, щоб не затягувати час старту системи, в
	Л╕накс╕ вдаються до деяких хитрощ╕в. Перший трюк: якщо ╕сну╓
	файл \cmd{/etc/fastboot}, то перев╕рка файлових систем не
	робиться. Другий трюк: файлова система ext2 ма╓ спец╕альний
	маркер, який вказу╓ на те, чи була ця файлова система
	в╕дмонтована в╕рно при попередньому монтуванн╕. Знаючи, що
	файлова система була розмонтована "<чистою"> (якщо прапорець
	вказу╓ на це) \cmd{e2fsck} (верс╕я \cmd{fsck} спец╕ал╕зована
	для перев╕рки файлово╖ системи ext2), може не перев╕ряти цю
	файлову систему. При цьому, звичайно, робиться припущення, що
	чисте розмонтування не приносить систем╕ проблем. Чи працю╓
	перший з трюк╕в (з файлом \fn{/etc/fastboot}) на Ваш╕й систем╕
	залежить в╕д стартових скрипт╕в системи, але трюк з прапорцем
	монтування ext2 спрацьову╓ кожного разу, коли Ви користу╓тесь
	\cmd{e2fsck}. Щоб змусити команду ╕гнорувати цей прапорець, це
	потр╕бно явно вказати за допомого параметра. (Детал╕ див╕ться
	в стор╕нц╕ п╕дказки \man{e2fsck}).

	Автоматична перев╕рка спрацьову╓ т╕льки для тих систем, як╕
	монтуються автоматично при старт╕ системи. Для перев╕рки ╕нших
	файлових систем, як, наприклад, дискет, користуйтесь
	\cmd{fsck}, запускаючи ╖╖ вручну. \begin{intnote}Команда \cmd{mount}
	в Л╕накс╕ ма╓ певний ╕нтелект. Якщо Ви вручну монту╓те файлову
	систему, яка не була перев╕рена, команда видасть попередження
	про це ╕ скаже, що рекоменду╓ться скористатися \cmd{e2fsck}
	для перев╕рки.\end{intnote}

	Якщо \cmd{fsck} при перев╕рц╕ натрапля╓ на файлову систему,
	яку вона не може в╕дремонтувати, тр Вас може спасти т╕льки
	одне з двох: або глибок╕ п╕знання про будову файлових систем
	взагал╕ ╕ даного типу конкретно, або гарна резервна
	коп╕я. Друге - зробити просто, а першого Ви можете досягти за
	допомогою друз╕в, п╕дписно╖ групи новин та п╕дписного листа по
	Л╕наксу чи задопомогою ╕нших засоб╕в знаходження ╕нформац╕╖. Я
	хот╕в би розпов╕сти про це б╕льше, але б╕л╕ плями в осв╕т╕ та
	досв╕д╕ не дають мен╕ цього зробити. Програма Теодора Цо
	\intnote{Theodore T'so} \cmd{debugfs} може Вам допомогти при
	цьому.

	Користуйтеся \cmd{fsck} т╕льки на розмонтованих файлових
	системах, н╕коли на змонтованих (за виключенням коренево╖
	файлово╖ системи при старт╕, яка монту╓тся при цьому т╕льки на
	читання). Через те, що \cmd{fsck} працю╓ з "<сирими">
	розд╕лами диску, вона може зм╕нювати файлов╕ системи так, що
	система про це нав╕ть не здогада╓ться. А якщо операц╕йну
	систему дурити, то непри╓мност╕ \emph{ трапляться}.


\subsection{Перев╕рка з╕псованих блок╕в за допомогою  \cmd{badblocks}}

	Перев╕рку зб╕йних блок╕в варто виконувати пер╕одично. Це можна
	робити командою \cmd{badblocks}. Вона вида╓ список знайдених
	зб╕йних блок╕в. Цей список пот╕м можна передати \cmd{fsck},
	щоб вона записала ц╕ дан╕ в структури даних файлово╖ системи з
	тим, щоб операц╕йна система могла б ними пот╕м скористатися
	щоб обходити зб╕йн╕ блоки при запис╕ даних. Наступний приклад
	показу╓ як це зробити.

		%
		\begin{quote}\tt
\verb|$| {\sl badblocks /dev/fd0H1440 1440 $>$ bad-blocks } \\
\verb|$| {\sl fsck -t ext2 -l bad-blocks /dev/fd0H1440} \\
\verb|Parallelizing fsck version 0.5a (5-Apr-94)| \\
\verb|e2fsck 0.5a, 5-Apr-94 for EXT2 FS 0.5, 94/03/10| \\
\verb|Pass 1: Checking inodes, blocks, and sizes| \\
\verb|Pass 2: Checking directory structure| \\
\verb|Pass 3: Checking directory connectivity| \\
\verb|Pass 4: Check reference counts.| \\
\verb|Pass 5: Checking group summary information.| \\
\verb| | \\
\verb|/dev/fd0H1440: ***** FILE SYSTEM WAS MODIFIED *****| \\
\verb|/dev/fd0H1440: 11/360 files, 63/1440 blocks| \\
\verb|$|
		\rm\end{quote}
		%

	Якщо \cmd{badblocks} пов╕домля╓ про з╕псований блок, який вже
	використано п╕д файл, \cmd{e2fsck} спробу╓ перем╕стити цей
	блок в ╕нше м╕сце. Якщо блок було пошкоджено серйозно, може
	виявитися, що файл, з╕псовано також.

\subsection{Боротьба з фра╜ментац╕╓ю}

	Не завжди можливо записати файл на диск як неперервну
	посл╕довн╕сть блок╕в. Про файл, який записано з розривами ("<не
	нерозривна"> посл╕довн╕сть блок╕в) кажуть, що в╕н
	\defin{фра╜ментований}. На прочитання фра╜ментованого файлу
	потр╕бно б╕льше часу оск╕льки читаюча/записуюча головка
	повинна зробити для цього б╕льше перем╕щень. Тому краще було б
	позбутися фра╜ментац╕╖, хоча в системах, як╕ мають добрий
	буфер з "<читанням наперед"> це ╕ невелика проблема.

	Файлова система ext2 намага╓ться утримувати фра╜ментац╕ю на
	м╕н╕мум╕, розташовуючи вс╕ блоки файлу разом, нав╕ть якщо ╖х
	не можна записати в посл╕довних секторах. Ext2 ефективно
	розташову╓ в╕льн╕ блоки, як╕ знаходяться по сус╕дству з ╕ншими
	блоками файлу. Тобто для ext2 р╕дко коли бува╓ необх╕дним
	турбуватися про фра╜ментац╕ю. ╤сну╓ програма для
	дефра╜ментац╕╖ ext2, див╕ться~\cite{ext2-defrag}. 

	╤сну╓ багато програм дефра╜ментац╕╖ для MS-DOS, як╕
	переписують блоки туди-сюди, щоб позбутися фра╜ментац╕╖
	файл╕в. Для ╕нших систем дефра╜ментац╕╖ можна досягти
	переписавши файлову систему ц╕ляком на резервн╕ нос╕╖ ╕
	в╕дновивши ╖╖ знову. Створення резервно╖ коп╕╖ перед
	дефра╜ментац╕╓ю взагал╕ непагана ╕дея для будь-яко╖ тако╖
	програми, оск╕льки багато чого може трапитися п╕д час роботи
	програми. 


\subsection{╤нш╕ програми для вс╕х файлових систем}

	╤снують ╕нш╕ засоби придатн╕ на щось корисне при робот╕ з
	файловими системами. \cmd{df} показу╓ ск╕льки в╕льного
	дискового простору залишилося на файлов╕й систем╕ (системах).
	\cmd{du} п╕драхову╓ ск╕льки м╕сця на диску займа╓ та чи ╕нша
	директор╕я та вс╕ ╖╖ файли. Обидв╕ програми можна
	використовувати в полюванн╕ за м╕сцем на диску.

	\cmd{sync} запису╓ вс╕ не записан╕ дос╕ блоки, як╕ знаходяться
	в буфер╕ кешу, на диск
	(див. розд╕л~\ref{sec:buffer-cache}). Дуже р╕дко трапляються
	ситуац╕╖, коли це потр╕бно робити вручну - процес-демон
	\cmd{update} викону╓ це автоматично. Це може знадобитись в
	катастроф╕чних ситуац╕ях, коли \cmd{update} або його
	процес-пом╕чник \cmd{bdflush} вмира╓, або Вам потр╕бно вимнути
	напругу, ╕ нема╓ часу чекати, поки \cmd{update} зробить свою
	справу. 

\subsection{╤нш╕ засоби для файлово╖ системи ext2}

	Додатково до програм, як╕ створюють (\cmd{mke2fs}) та
	перев╕ряють ц╕л╕сн╕сть (\cmd{e2fsck}) файлово╖ системи, ╕ якими
	можна користуватися або безпосередньо, або ж через ╖х незалежну
	в╕д типу файлово╖ системи "<фасадну"> програму, ╕снують деяк╕
	╕нш╕ додактков╕ засоби для ext2.

	\cmd{tune2fs} служить для п╕дгонки параметр╕в файлово╖
	системи. Деяк╕ з найб╕льш ц╕кавих параметр╕в так╕:

		% 
       \begin{itemize} 

       \item Найб╕льша допустима к╕льк╕сть монтувань. Якщо файлова
             система була змонтована ╕ розмонтована без перев╕рки
             багато раз╕в, \cmd{e2fsck} насильно перев╕ря╓ файлову
             систему, нав╕ть якщо вона була розмонтована чисто. Для
             систем, що використовуються для розробки чи для 
             випробовування, корисною порадою було б цей номер
             зменшити.

        \item Максимальний час м╕ж перев╕рками. \cmd{e2fsck} також
                може примусово перев╕ряти файлову систему, якщо час
                м╕ж перев╕рками досягнуто, нав╕ть якщо прапорець
                чистоти встановлено, ╕ система монту╓ться не дуже
                часто. Однак, цей параметр можна в╕дм╕нити.

        \item К╕льк╕сть блок╕в зарезервованих для
                \texttt{root}'а. Ext2 резерву╓ певну частину блок╕в
                для використання \texttt{root}'ом. Таким чином,
                нав╕ть, якщо файлова система переповню╓ться, для
                системного адм╕н╕стратора доступний деякий прост╕р, ╕
                ще можна дещо зробити не стираючи файл╕в. Як звично,
                такий резервний прост╕р встановлю╓ться на р╕вн╕ 5\%,
                що для б╕льшост╕ диск╕в ╓ припустимою величиною. Для
                дискет, однак, не ма╓ н╕якого сенсу резервування
                жодного блока.

	\end{itemize}
		%
        Стор╕нка п╕дказки по \man{tune2fs} надасть Вам б╕льше
       ╕нформац╕╖ по програм╕.

	\cmd{dumpe2fs} показу╓ ╕нформац╕ю про файлову систему ext2, в
	основному ╕нформац╕ю з супер-блока. Зразок того, що вида╓ ця
	програма показано на рис.~\ref{fig:dump2fs-output}. Деяк╕
	дан╕, що видаються ╓ досить техн╕чними ╕ потребують розум╕ння
	того, як працю╓ файлова система
	(див. додаток~\ref{chap:ext2fspaper}, але б╕льш╕сть зрозум╕ла
	нав╕ть системним адм╕н╕страторам. 


\begin{figure}[t]
\begin{center}
\small
\begin{verbatim}
dumpe2fs 0.5b, 11-Mar-95 for EXT2 FS 0.5a, 94/10/23
Filesystem magic number:  0xEF53
Filesystem state:         clean
Errors behavior:          Continue
Inode count:              360
Block count:              1440
Reserved block count:     72
Free blocks:              1133
Free inodes:              326
First block:              1
Block size:               1024
Fragment size:            1024
Blocks per group:         8192
Fragments per group:      8192
Inodes per group:         360
Last mount time:          Tue Aug  8 01:52:52 1995
Last write time:          Tue Aug  8 01:53:28 1995
Mount count:              3
Maximum mount count:      20
Last checked:             Tue Aug  8 01:06:31 1995
Check interval:           0
Reserved blocks uid:      0 (user root)
Reserved blocks gid:      0 (group root)

Group 0:
  Block bitmap at 3, Inode bitmap at 4, Inode table at 5
  1133 free blocks, 326 free inodes, 2 directories
  Free blocks: 307-1439
  Free inodes: 35-360
\end{verbatim}
\end{center}
\caption{Зразок роботи  \cmd{dumpe2fs}}
\label{fig:dumpe2fs-output}
\end{figure}

	\cmd{debugfs} ╓ в╕дладчиком файлово╖ системи. В╕н дозволя╓
	прямий доступ до структур даних, що записуються на диск, тобто
	його можна використовувати для в╕дновлення тих диск╕в, як╕
	з╕псован╕ наст╕льки, що \cmd{fsck} в╕дновити ╖х вже не
	може. Про цю програму також просочувалися дан╕, що 
	\cmd{debugfs} можна використовувати також для в╕дновлення
	стертих файл╕в. Однак, робота з ц╕╓ю програмою вимага╓ дуже
	глибоких знань того, що Ви хочете зробити. Недостатн╕ знання
	можуть знищити вс╕ Ваш╕ дан╕. 

	\cmd{dump} та \cmd{restore} служать для створення резервних
	коп╕й файлово╖ системи ext2. Вони належать до традиц╕йних
	засоб╕в Юн╕кса по створенню резерних коп╕й, але ╓ специф╕чними
	для файлово╖ системи ext2. Детальн╕ша ╕нформац╕я про це ╓ в
	розд╕л╕~\ref{chap:backups}.

\section{Диски без файлових систем}

	Не вс╕ диски чи п╕дрозд╕ли використовуються як файлов╕
	системи. П╕дрозд╕л, що м╕стить прост╕р для своп╕н╜у,
	наприклад, не ма╓ файлово╖ системи. Б╕льш╕сть дискет
	використовуються под╕бно до стр╕чок, так, що \cmd{tar} чи ╕нш╕
	под╕бн╕ програми записують дан╕ безпосередньо на диск без
	файлово╖ системи. Завантажувальн╕ дискети Л╕накса не мають файлово╖
	системи, а м╕стять т╕льки ядро системи.

	В╕дмова в╕д створення файлово╖ системи ма╓ т╕ переваги, що
	дисковий прост╕р використову╓ься б╕льш повно "--- без зайво╖
	втрати його на обл╕ков╕ функц╕╖ файлово╖ системи. Кр╕м цього
	так╕ диски ╓ б╕льш сум╕сними з ╕ншими системами. Наприклад,
	для вс╕х систем формат \cmd{tar} ╓ одним ╕ тим же, не
	дивлячись на те, що файлов╕ системи в╕др╕зняються в╕д одн╕╓╖
	системи до ╕ншо╖. Ви швидко звикнете користуватися дисками без
	файлових систем в раз╕ необх╕дност╕. Завантажувальн╕ диски Л╕накса
	теж часто не мають файлово╖ системи, хоча можуть ╕ мати.

	Ще одн╕╓ю причиною для користування "<сирими"> дисками ╓
	необх╕дн╕сть зробити коп╕╖ "<образу"> або зображення з
	них. Наприклад, якщо на диску знаходиться файлова система, яка
	т╕льки частково пошкоджена, варто б зробити точну коп╕ю
	файлово╖ системи, перш, н╕ж намагатися ╖╖ в╕дновити, оск╕льки
	в раз╕ неудач╕ Ви завжди зможете почати спочатку. Один ╕з
	способ╕в це зробити - за допомогою команди \cmd{dd}:

		%
		\begin{quote}\tt
\verb|$| {\sl dd if=/dev/fd0H1440 of=floppy-image} \\
\verb|2880+0 records in| \\
\verb|2880+0 records out| \\
\verb|$| {\sl dd if=floppy-image of=/dev/fd0H1440 } \\
\verb|2880+0 records in| \\
\verb|2880+0 records out| \\
\verb|$|
\verb|$|
		\rm\end{quote}
		%

	Перша команда \cmd{dd}	створю╓ точний образ дискети в файл╕
	\fn{floppy-image}, а друга з них запису╓ це зображення на
	дискету (Спод╕ва╓мось, що користувач здогада╓ться зам╕нити
	дискету в дисковод╕ м╕ж двома цими командами. ╤накше ця пара
	команд ма╓ мало сенсу.). 

\section{Вид╕лення дискового простору}

\subsection{Схеми розд╕лу диск╕в}

	Дуже нелегко розбити диск на розд╕ли найкращим чином. ╤ що ще
	г╕рше - не ╕сну╓ н╕яко╖ ун╕версально╖ поради як це
	робити. Занадто багато фактор╕в впливають на к╕нцевий
	результат.

	Традиц╕йно вважа╓ться доц╕льним створення (в╕дносно) невелико╖
	коренево╖ файлово╖ системи, на як╕й будуть збер╕гатися
	\fn{/bin}, \fn{/etc}, \fn{/dev}, \fn{/lib}, \fn{/tmp} та ╕нш╕
	необх╕дн╕ для початку роботи системи реч╕. Таким чином
	коренева файлова система (на окремому розд╕л╕, або ж на сво╓му
	власному диску) - це все, що потр╕бно для того, щоб привести
	систему в робочий стан. Пояснення до цього може бути таке --
	якщо коренева файлова система невеличка ╕ не дуже активно
	використову╓ться, то вона ма╓ менше шанс╕в бути з╕псованою п╕д
	час краху системи. Тобто, ╖╖ легше можна в╕дновити п╕сля
	краху. П╕сля цього Ви можете створити окрем╕ розд╕ли диску (чи
	окрем╕ диски) для дерева директор╕й, що йде п╕д \fn{/usr}, для
	домашн╕х директор╕й користувач╕в (найчаст╕ше п╕д \fn{/home})
	та для простору своп╕н╜у. В╕дд╕лення домашн╕х директор╕й
	користувач╕в в св╕й окремий розд╕л ма╓ т╕ переваги, що
	створення резервних коп╕й в цьому раз╕ ста╓ прост╕шим,
	оск╕льки не ма╓ сенсу дуже часто арх╕вувати програми, що
	знаходяться п╕д \fn{/usr} \begin{intnote}
%
	В╕д себе можу додати, що це також зменшу╓ проблеми з
	системою. Якщо система не користу╓ться квотами (р╕дко хто ма╓
	бажання псувати в╕дносини з користувачами), то рано чи п╕зно,
	не залежно в╕д розм╕ру диску, вид╕леного п╕д домашн╕
	директор╕╖, в╕н переповниться. ╤ нав╕ть якщо  Ви й змушен╕ будете
	розсилати користувачам пов╕домлення: "<Панове, чи не будете Ви
	наст╕льки ласкавими зтерти непотр╕бн╕ файли в Ваших домашн╕х
	директор╕ях">, або "<Панове: \cmd{
\$(cd /home; du -s * | sort -nr | head -10 | awk ' \{ print \$2\}') | xargs rm -rf">! 
	}
		%
	(Якщо не зрозум╕ло, що це означа╓, не варто посп╕шати
	друкувати команду в командному рядку, щоб подивитися, що
	вона робить. Спробуйте спочатку роз╕братися.) Але при всьому
	цьому система залиша╓ться в робочому стан╕, ╕ не залежно в╕д
	того наск╕льки довго користувач╕ будуть борсатися в файлов╕й
	системи заповнен╕й на 99-100\%, Ви зможете зловт╕шно
	усм╕хаючись, встановлювати нов╕ програми п╕д
	\fn{/usr/local/games}.  

	\end{intnote} Кр╕м того, якщо комп'ютери об'╓днан╕ в мережу, можна також
	використовувати одну ╕ ту ж директор╕ю \fn{/usr} ╕з сервера
	сп╕льно для багатьох комп'ютер╕в (наприклад, користуючись
	NFS). Таким чином зменшу╓ться загальний дисковий прост╕р,
	необх╕дний для вс╕╓╖ системи (економ╕я може становити десятки
	або сотн╕ мегабайт помножен╕ на число машин в мереж╕).

	Проблеми, як╕ виникають коли Ви ма╓те багато розд╕л╕в,
	полягають в основному в тому, що в╕льний прост╕р на диску
	виявля╓ться розд╕леним на багато невеликих шматк╕в
	розпод╕лених по вс╕х розд╕лах. В наш час, коли диски та
	операц╕йн╕ системи стають (як ми на це спод╕ва╓мось) б╕льш
	над╕йними, багато хто в╕ддасть перевагу одному ╓диному
	розд╕лу, на якому збер╕гаються вс╕ файли. З ╕ншого боку,
	створення резервно╖ коп╕╖ та в╕дновлення невеликого розд╕лу
	буде менш болючим.

	
%	\meta more reasons for many partitions: users/temp files/spools
%	can't fill up all disks, readonly partitions less likely to corrupt, 
%	fsck is faster, limits losses a filesystem goes really wrong,
%	logging must not be disturbed, boots from >1023 cylinders do not
%	work on all BIOS's, /usr/local won't be disturbed by an upgrade,
%	easy to divide backup on many tapes, spare (scratch) partition for
%	experimentation (e.g., a new Linux distribution), scratch can
%	also be used to backup root during upgrades

	Для невеликого диску (якщо Ви не займа╓тесь програмуванням
	ядра системи), найкраще мати один ╓диний розд╕л. Для великих
	диск╕в, можливо краще мати к╕лька великих розд╕л╕в, на той
	випадок, якщо щось буде не так, як хот╕лося б. (Сл╕д
	в╕дзначити, що ми вжива╓мо `мал╕' ╕ `велик╕' у дуже в╕дносному
	смисл╕ - чим б╕льш╕ Ви ма╓те диски, тим б╕льшим буде `велике').

	Якщо Ви ма╓те к╕лька диск╕в, Ви можливо захочете створити
	кореневу систему (разом з \fn{/usr}) на одному диску, а
	домашн╕ директор╕╖ пом╕стити на ╕ншому.

	Будьте готов╕ до деякого експериментування з р╕зноман╕тними
	схемами под╕лу диск╕в на розд╕ли (з часом, не т╕льки п╕д час
	встановлення системи). Це - добрий шматок роботи, оск╕льки
	вимага╓ встановлення системи в╕д самого початку к╕лька раз╕в,
	але, це ╓диний над╕йний спос╕б впевнитися, що Ви робите все
	в╕рно\intnote{ Дозволю соб╕ знову невелику сваволю - не
	погоджусь з автором щодо перевстановлення системи багато
	раз╕в. Юн╕кс на те ╕ ╓ Юн╕кс, що не вимага╓ в багатьох
	випадках того, чого вимагають ╕нш╕ системи - перегрузок та
	перевстановлень системи. Як т╕льки система приведена в
	б╕льш-менш робочий стан, тобто встановлена конф╕╜урац╕я,
	створен╕ користувач╕ системи, тощо, нема╓ н╕ найменшого сенсу
	╖╖ знищувати. Нав╕ть якщо Ви помилилися з розпод╕лом дискового
	простору з першого разу (або здобули в процес╕ роботи
	необх╕дний досв╕д для того, щоб зробити цей розпод╕л кращим,
	Вам достатньо мати такий-сякий в╕льний диск (або добрий,
	над╕йний зас╕б для резервно╖ коп╕╖ - стр╕чка чи ще що-небудь),
	щоб перенести на нього потр╕бн╕ розд╕ли диску та повернути ╖х
	на перв╕сний диск п╕сля його перерозпод╕лу. Пам'ятайте, що в
	Юн╕кс╕ (а тим паче в Л╕накс╕) Ви ма╓те доступ до вс╕х
	системних ресурс╕в за допомогою звичайний команд - Ви можете
	переносити систему з диску на диск, встановлювати завантажувальн╕
	сектори на т╕ диски, як╕ Ви забажа╓те, можете зм╕нювати
	головний завантажувальний блок (MBR) за бажанням та в╕дновлювати
	його, не забувайте одного ╓диного правила при цьому - RTFM
	(або, як це приблизно можна перекласти "<вивчайте матер╕альну
	частину">. Спод╕ва╓мось допитливий читач зможе в╕дшукати б╕льш
	досл╕вний переклад ц╕╓╖ абрев╕атури самост╕йно).}.

\subsection{Вимоги до дискового простору}

	Документац╕я до тих комплект╕в Л╕накса, як╕ Ви будете
	встановлювати, дасть Вам деяке поняття про те, ск╕льки
	дискового простору Вам необх╕дно для встановлення
	системи. Додайте до цього необх╕дне м╕сце на диску для
	програм, що ╖х потр╕бно встановлювати самост╕йно. Ц╕ дан╕
	допоможуть Вам спланувати використання дисково╖ пам'ят╕, але
	кр╕м цього необх╕дно приготуватися до майбутнього розширення
	системи ╕ зарезервувати прост╕р п╕д нього.

	Конкретн╕ дан╕ залежать в╕д того, що саме збираються робити
	Ваш╕ користувач╕. Звичайно ж б╕льш╕сть людей хочуть мати
	ст╕льки дискового простору, ск╕льки це т╕льки можливо, але
	величина простору, маючи яку вони зможуть жити спок╕йно
	залежить в╕д багатьох чинник╕в. Деяк╕ люди займаються
	друкуванням текст╕в ╕ можуть легко об╕йтися к╕лькома
	ме╜абайтами, але ╕нш╕ займаються обробкою величезних зображень
	╕ потребують для сво╓╖ роботи ╜╕╜абайт╕в.

	До реч╕, пор╕внюючи розм╕ри диск╕в в к╕лобайтах, ме╜абайтах та
	╜╕╜абайтах, зважайте на те, що ц╕ величини можуть бути
	р╕зними. Деяк╕ виробники диск╕в хочуть вважати, що к╕лобайт -
	це 1000 байт ╕ що ме╜абайт - 1000 к╕лобайт, хоча весь
	комп'ютерний св╕т в обох випадках користу╓ться множником
	1024. Тобто, м╕й 345~МБ диск насправд╕ ╓
	330~МБайтним.\footnote{Sic transit discus mundi.} 

	Про вид╕лення м╕сця п╕д своп╕н╜ читайте в розд╕л╕~\ref{sec:swap-alloc}.

\subsection{Деяк╕ зразки розд╕лу диск╕в}

	Ран╕ше я користувався диском об'╓мом 109~МБайт, тепер я маю
	330~МБайтний. Я поясню, як я розд╕лив ц╕ диски на п╕дрозд╕ли. 

	109~МБайтний диск я розбивав тисячами способ╕в тод╕, коли мо╖
	потреби зм╕нювалися. Було два типових сценар╕╖. Спочатку я
	користувався MS-DOS'ом разом з Л╕наксом. Мен╕ потр╕бно було
	б╕ля 20~МБайт простору на диску, щоб мати м╕н╕мальний DOS,
	комп╕лятор С╕, редактор, к╕лька ╕нших програмок та трохи
	в╕льного простору, щоб не в╕дчувати клаустрофоб╕╖. Для Л╕накса
	я мав 10~МБайтний своп-п╕дрозд╕л ╕ решта (тобто 79~МБайт)
	належала вс╕м Л╕накс╕вським файлам на одному розд╕л╕. Я
	експериментував з окремими розд╕лами для кореня, \fn{/usr},
	\fn{/home}, але у мене не було н╕коли достатньо простору одним
	шматком наст╕льки великим, щоб мене це зац╕кавило.

	Коли я втратив потребу в DOS-╕, я переформатував диск так, що
	я мав 12~МБайтний розд╕л п╕д своп╕н╜ ╕ знову ж таки решта йшла
	на один розд╕л.

	330~МБайтний диск я розд╕лив на к╕лька п╕дрозд╕л╕в приблизно так:
		%
		\begin{quote}
		\begin{tabular}{r l}
	  	  5 MB & коренева файлова система \\
	 	 10 MB & п╕дрозд╕л для своп╕н╜у \\
		180 MB & файлова система \fn{/usr} \\
		120 MB & файлова система \fn{/home} \\
	 	 15 MB & чорновий розд╕л
		\end{tabular}
		\end{quote}
		%

	Чорновий розд╕л використовувася для деяких експеримент╕в з
	р╕зномн╕тними речами, як╕ вимагають власного п╕дрозд╕лу, тобто
	для р╕зних верс╕й Л╕накса чи для пор╕вняння швидкостей
	файлових систем. Коли цей розд╕л не використовувався н╕ п╕д
	що, я робив з нього прост╕р п╕д своп╕н╜ (я люблю мати {\em
	багато} в╕дкритих в╕кон).

\subsection{Як додати нов╕ диски до Л╕наксу}

	Додання нового дискового простору до Л╕наксу - справа проста,
	якщо вся апаратура встановлена ╕ сконф╕╜урована (встановлення
	апаратури не розгляда╓ться в ц╕й книжц╕). Ви формату╓те диски
	так, як Вам потр╕бно, створю╓те п╕дрозд╕ли та файлов╕ системи,
	так як це було описано ран╕ше та дода╓те в╕дпов╕дн╕ рядки до
	\fn{/etc/fstab}, щоб п╕дрозд╕ли монтувалися автоматично.

\subsection{Економ╕я дискового простору}

	Найкраща порада - це не встановлювати непотр╕бн╕
	програми. Б╕льш╕сть верс╕й Л╕накса запропону╓ при установц╕
	деяк╕ вар╕анти для вибору тих пакет╕в, що будуть
	встановлен╕. Проанал╕зувавши список, Ви можете прийти до
	висновку, що Вам не потр╕бна б╕льш╕сть ╕з цих пакет╕в. Це
	збереже Вам море м╕сця. Нав╕ть, якщо Вам потр╕бна якась певна
	програма, можливо, що Вам не потр╕бна вона вся. Наприклад,
	деяка документац╕я може не знадобитися, так само, як можуть
	бути непотр╕бними деяк╕ Elisp файли для GNU Emacs'а, деяк╕
	шрифти для X11 або деяк╕ б╕бл╕отеки для програмування. 

	Якщо не можна стерти певн╕ пакети, можливо ╖х можна
	стиснути. Програми стискання файл╕в, так╕, як \cmd{gzip} та
	\cmd{zip} стиснуть (так само як ╕ розширять) ╕ндив╕дуальн╕
	файли чи групи файл╕в\begin{intnote}Традиц╕йним для Юн╕кс╕в ╓
	\cmd{compress} для стискання файл╕в та \cmd{uncompress} чи
	\cmd{zcat} для ╖х розширення\end{intnote}. \cmd{gzexe} може стискати та
	розширяти файли непом╕тно для користувача (програми, як╕ не
	використовуються, стискаються та розширюються п╕зн╕ше, тод╕
	коли вони знадобляться). Експериментальна система \cmd{DouBle}
	зможе стискати вс╕ файли в файлов╕й систем╕ непом╕тно для
	програм, як╕ ними користуються. Якщо Ви знайом╕ з такими
	продуктами, як Stacker для DOS\intnote{чи для Macinosh'а}, то
	принцип роботи той же.

