%--------------------------------------------------------------------
\chapter{Резервн╕ коп╕╖} \label{chap:backups}
%--------------------------------------------------------------------

	\begin{verse}\it
	Апаратура непередбачувано над╕йна.   \\
	Програмне забезпечення непередбачувано ненад╕йне.  \\
	Люди непередбачувано ненад╕йн╕.  \\
	Природа непередбачувано над╕йна.   \\
	\rm\end{verse}

	\noindent
	Цей розд╕л поясню╓ чому, як ╕ коли робити резервне коп╕ювання,
	╕ як в╕дновлювати загублен╕ реч╕ з резервних коп╕й.

\section{Про важлив╕сть мати резервн╕ коп╕╖}

	Ваш╕ дан╕ важлив╕. ╥х в╕дновлення буде варте Вашого часу ╕
	зусиль, а це - варте грошей, або, як м╕н╕мум, власниих
	переживань та сл╕з. Деяк╕ дан╕ неможливо створити заново,
	наприклад, якщо це - результати якогось експерименту. Оск╕льки
	це - вкладення кап╕талу, Ви ма╓те ╖х захищати та намагатися не
	загубити. 

	Ви можете загубити сво╖ дан╕ в основному з чотирьох причин:
	з╕псована апаратура, помилки в програмах, д╕╖ людей та
	природн╕ лиха.\footnote{Ще ╓ п'ята причина - "<щось ╕нше">.}
	Хоча сучасна апаратура ста╓ все б╕льш над╕йною, вона все таки
	може псуватися, як ╕нколи зда╓ться, неспод╕вано. Найб╕льш
	важлив╕ для збереження даних пристро╖ - це жорстк╕ диски, як╕
	залежать в╕д невидимих, крих╕тних магн╕тних пол╕в ╕ живуть в
	св╕т╕ переповненому електромагн╕тними шумами. Сучасн╕ програми
	нав╕ть ╕ не намагаються бути над╕йними. Зал╕зобетонно-над╕йн╕
	програми в сучасному св╕т╕ - це виключення, а не правило. Люди
	досить ненад╕йн╕, вони або роблять помилки, або, будучи
	п╕длими по натур╕, просто навмисне псують дан╕. Природа, може
	нав╕ть ╕ не диявольска по сво╖й натур╕, але може приносити
	сюрпризи нав╕ть коли вона чудова та лаг╕дна. Беручи все це до
	уваги, залиша╓ться т╕льки дивуватися, як все оце ще дос╕
	працю╓.

	Створення резервних коп╕й - це шлях до збереження вкладеного в
	створення даних кап╕талу. Маючи к╕лька резервних коп╕й Ви можете не
	турбуватися про те, ск╕льки даних (який ╖х в╕дсоток)
	знищено. Варт╕сть повернення даних буде всього навсього
	варт╕стю в╕дновлення даних з резервно╖ коп╕╖. 

	Найб╕льш важливим ╓ робити резервування даних в╕рно. Так само,
	як ╕ на все ╕нше, на це вплива╓ повсякденне життя, ╕ тому рано
	чи п╕зно резервна коп╕я з╕псу╓ться. Частиною роботи з
	резервування ╓ перев╕рка, що резервн╕ коп╕╖ працюють. Напевно
	б п╕д час в╕дновлення даних Вам не хот╕лося д╕знатися, що Ваше
	резервування не працювало\footnote{Не см╕йтеся - це сталося не
	з одн╕╓ю людиною.} Нав╕ть б╕льше того, найжахлив╕ший крах може
	статися якраз п╕д час створення резервних коп╕й. Якщо у Вас ╓
	один нос╕й для резервування, може виявитися, що цей нос╕й
	з╕псований, ╕ Ви опиня╓тесь на попелищ╕, залишеному на м╕сц╕
	важко╖ роботи.\footnote{Вже тут був, ╕ вже це бачив\dots} Або,
	в╕дновлюючи що-небудь з резервно╖ коп╕╖, може раптом
	виявитися, що щось дуже важливе, щось таке, наприклад, як база
	даних сервера на 15~000~користувач╕в, залишилося не
	заарх╕вованим. ╤ що ще краще, вс╕ Ваш╕ коп╕╖ можуть
	працювати бездоганно, але саме той прив╕д стр╕чки, яким Ви
	користувалися, був ╓диним в сво╓му род╕ ╕ сто╖ть тепер
	наповнений по в╕нця водою.

	Коли Ви почина╓те планувати створення резевних коп╕й, то
	паранойя ╓ необх╕дним станом душ╕.

\section{Виб╕р нос╕╖в для створення резервних коп╕й}

	Найважлив╕ше р╕шення, що стосу╓ться резервування даних - це
	виб╕р нос╕╖в для створення резервних коп╕й. Вважати треба на
	варт╕сть, над╕йн╕сть, швидк╕сть та зручн╕сть користування.

	Варт╕сть важлива, оск╕льки, напевне у Вас буде резервних коп╕й
	по об'╓му в к╕лька раз╕в б╕льше, н╕ж даних. Сл╕д розраховувати
	на дешев╕ нос╕╖.

	Над╕йн╕сть надзвичайно важлива - з╕псована резервна коп╕я може
	довести мужнього героя до сл╕з. Нос╕╖ резевних коп╕й повинн╕
	збер╕гати дан╕ без втрат по к╕лька рок╕в. Спос╕б ╖х
	використання також вплива╓ на ╖х над╕йн╕сть. Жорсткий диск -
	дуже над╕йний. Але якщо диск використову╓ться як нос╕й для
	резервного коп╕ювання - в╕н не дуже над╕йний, бо в╕н
	знаходиться в тому ж комп'ютер╕, що ╕ основний диск.

	Швидк╕сть, як правило, не дуже важлива, якщо т╕льки Ви можете
	зробити все потр╕бне резервування без переривання. Н╕чого
	страшного, що запис резервно╖ коп╕╖ займа╓ дв╕ години, якщо
	при цьому не потр╕бно Ваше втручання. Але, якщо Ви не
	встига╓те робити резервування за той час, поки комп'ютер не
	завантажений справжньою роботою, швидк╕сть набува╓ вагу.

	Наявн╕сть нос╕╖в та пристро╖в - очевидна необх╕дн╕сть, - Ви не
	зможете зробити резервну коп╕ю, якщо таких нос╕╖в, як
	потр╕бно, не ╕сну╓. Але наявн╕сть вибраного пристрою в
	майбутньому ╓ не наст╕льки очевидою вимогою (╕ саме для того
	комп'ютера, що Ви ма╓те). Не маючи потр╕бного пристрою Ви
	просто не зможете в╕дновити дан╕ п╕сля катастрофи.

	Зручн╕сть в користуванн╕ ╓ надзвичайно важливим фактором у
	визначенн╕ того, як часто Ви створю╓те резервн╕ коп╕╖. Чим
	прост╕ше це робити, тим краще. Користування нос╕ями не повинно
	бути важким чи втомлюючим. 

	Найб╕льш типов╕ вар╕анти нос╕╖в для резервування - це дискети
	та магн╕тн╕ стр╕чки. Дискети дуже дешев╕, досить над╕йн╕ ╕ ╓ в
	наявност╕. Але для великих об'╓м╕в - незручн╕ в
	користуванн╕. Стр╕чки по вартост╕ лежать в д╕апазон╕ в╕д
	дешевих до дещо дорогших, досить над╕йн╕, досить швидк╕ ╕ 
	достатньо доступн╕. Вважаючи на ╖х об'╓м, стр╕чки також досить
	зручн╕ в користуванн╕.

	╢ також ╕нш╕ вар╕анти для вибору. ╤нколи вони не наст╕льки
	доступн╕, але коли виб╕р не ╓ проблемою, вони можуть бути
	кращими в ╕нших в╕дношеннях. Наприклад, магн╕тно-оптичн╕ диски
	мають позитивн╕ якост╕, успадкован╕ як в╕д дискет - (дов╕льний
	доступ до даних дозволя╓ швидко в╕дшукати потр╕бний файл), так
	╕ в╕д стр╕чок (можуть збер╕гати величезну к╕льк╕сть даних).

\section{Виб╕р засоб╕в для створення резервних коп╕й}

	Для створення резервних коп╕й ╕сну╓ безл╕ч засоб╕в. Традиц╕йн╕
	засоби Юн╕кса - це команди \cmd{tar}, \cmd{cpio} та
	\cmd{dump}. Додатково до цього ╕снують ╕нш╕ пакети (як
	безкоштовн╕, так ╕ комерц╕йн╕). На виб╕р конкретного засобу
	вплива╓ також виб╕р нос╕я. 

	\cmd{tar} та \cmd{cpio} - под╕бн╕ м╕ж собою, ╕ з точки зору
	резервного коп╕ювання майже однаков╕. Обидв╕ програми можуть
	збер╕гати дан╕ на стр╕чках та читати ╖х зв╕дти. Обидв╕ можуть
	користуватися практично будь-якими нос╕ями для запису,
	оск╕льки драйвери низького р╕вня в ядр╕ п╕клуються про роботу
	з пристроями ╕ вс╕ пристро╖ виглядають практично однаково для
	програм р╕вня користувача. Деяк╕ верс╕╖ традиц╕йних
	Юн╕ксовських \cmd{tar} та \cmd{cpio} можуть мати деяк╕
	проблеми з незвичайними файлами (символ╕чними ссилками,
	спец╕альними файлами пристро╖в, файлами з занадто довгими
	назвами, тощо
	\begin{intnote}
	Наприклад, \cmd{tar} в SunOS не може
	коп╕ювати файли спец╕альних пристро╖в (\texttt{/dev/*})
	\end{intnote}
	), але Л╕накс╕вськ╕ верс╕╖ поводяться з усим цим так, як треба.

	\cmd{dump} в╕др╕зня╓ться тим, що в╕н чита╓ безпосередньо
	файлову систему , а не файли через файлову систему. Кр╕м того в╕н
	написаний спец╕ально для створення резервних коп╕й, в той час,
	як \cmd{tar} та \cmd{cpio} насправд╕ створен╕ для арх╕вування
	даних, хоча ╕ можуть робити резервн╕ коп╕╖ також.

	Звертання прямо до файлово╖ системи ма╓ деяк╕ переваги. Це
	робить можливим арх╕вування файл╕в без зм╕ни ╖х дат, щоб
	досягти цього ж за допомогою \cmd{tar} та \cmd{cpio} Вам
	потр╕бно було б спочатку монтувати файлову систему в режим╕
	т╕льки читання. Також пряме читання з файлово╖ системи
	ефективн╕ше, тод╕, коли потр╕бно створити резервну коп╕ю вс╕╓╖
	файлово╖ системи, оск╕льки менше часу витрача╓ться на перев╕д
	магн╕тно╖ головки. Основним недол╕ком ╓ залежн╕сть в╕д типу
	файлово╖ системи - кожна програма розум╕╓ одну ╓дину файлову
	систему.  Л╕накс╕вська верс╕я \cmd{dump} може працювати
	т╕льки з файловою системою ext2.

	\cmd{dump} також п╕дтриму╓ безпосередньо р╕вн╕ створення
	резервних коп╕й (про як╕ буде трохи дал╕); при використанн╕
	команд \cmd{tar} та \cmd{cpio} це треба робити за допомогою
	╕нших засоб╕в. 

	Пор╕вняння ╕нших засоб╕в для створення резезвних коп╕й
	виходить поза меж╕ тематики ц╕╓╖ книжки. Багато засоб╕в
	приведено на  Linux Software Map.
	
\section{Просте резервування}

	Найпрост╕ша схема резезвування - це зарезервувати все
	абсолютно за один раз, а пот╕м резервувати все, що зм╕нилося з
	часу попереднього резервування. Перше резервування носить
	назву \defin{повного резервування}\intnote{full backup},
	наступн╕ п╕сля нього "--- "<доповнююч╕ коп╕╖">\intnote{incremental
	backups}. Повна коп╕я част╕ше вимага╓ б╕льше роботи, н╕ж
	доповнююч╕, через те, що потр╕бно записати б╕льше даних на
	стр╕чку, ╕, можливо, що вс╕ дан╕ не пом╕стяться на одну
	стр╕чку (або дискету). В╕дновлення файл╕в з доповнюючих коп╕й
	може вимагати набагато б╕льшо╖ роботи, н╕ж в╕дновлення з
	повно╖ коп╕╖. В╕дновлення файл╕в можна оптим╕зувати таким
	чином, щоб в╕дновлен╕ файли завжди бралися з останньо╖ повно╖
	коп╕╖. Таким чином, можливо резервування вимага╓ трохи б╕льше
	роботи, але, може трапитися, що Вам н╕коли не буде потр╕бно
	в╕дновлювати файл з повно╖ коп╕╖ ╕ доповнювати його з
	доповнюючо╖.

	Якщо Ви плану╓те робити резервн╕ коп╕╖ кожного дня ╕ ма╓те
	ш╕сть стр╕чок для цього, Ви можете використати стр╕чку~1 для
	першо╖ повно╖ коп╕╖ (скаж╕мо, в п'ятницю), ╕ стр╕чки~2-~5 для
	доповнюючо╖ коп╕╖ (в╕д понед╕лка до четверга). Пот╕м Ви робите
	нову повну коп╕ю на стр╕чц╕ 6 (друго╖ п'ятниц╕) ╕ почина╓те
	робити доповнююч╕ коп╕╖ з стр╕чками~2-5 знову. Намагайтеся не
	стерти стр╕чку 1 до того, часу поки Ви не будете мати ново╖
	повно╖ коп╕╖, на той випадок, якщо щось трапиться п╕д час
	створення друго╖ повно╖ коп╕╖. Нав╕ть п╕сля того, як Ви
	зробили другу повну коп╕ю, тримайте першу коп╕ю десь в
	безпечному м╕сц╕, раптом вс╕ наступн╕ коп╕╖ будуть знищеними
	(в╕д вогню, чи ще в╕д чогось), Ви все-таки матимете щось в
	руках. Коли Вам потр╕бно буде зробити наступну повну коп╕ю,
	роб╕ть ╖╖ на стр╕чц╕~1, а стр╕чку~6 в╕дклад╕ть. 

	Якщо Ви ма╓те б╕льше, н╕ж 6 стр╕чок, Ви можете використовувати
	додатков╕ з них для ╕нших повних коп╕й. Кожного разу, коли Ви
	робите нову повну коп╕ю, використовуйте найстар╕шу
	стр╕чку. Таким чином, Ви можете мати повн╕ коп╕╖ за к╕лька
	попередн╕х тижн╕в, що дуже добре, якщо Вам потр╕бно в╕дшукати
	якийсь старий файл, що Ви вже його стерли, або стару верс╕ю
	файлу. 


\subsection{Створення повних коп╕й з \cmd{tar}}

	Повна коп╕я може дуже просто бути створена командою \cmd{tar}:
		%
		\begin{quote}\tt
\# tar --create --file /dev/ftape /usr/src \\
tar: Removing leading / from absolute path names in the archive \\
\# 
		\rm\end{quote}
		%

	Зразок команди поданий тут використову╓ GNU верс╕ю \cmd{tar} ╕
	прийнят╕ для ц╕╓╖ верс╕╖ довг╕ командн╕ опц╕╖. Традиц╕йн╕
	верс╕╖ \cmd{tar} розум╕ють т╕льки опц╕╖, що складаються з
	одн╕╓╖ л╕тери. Верс╕я GNU також може створювати коп╕╖, що не
	пом╕щаються на одну стр╕чку чи дискету, та так╕, як╕ мають
	файли з дуже довгими маршрутами. Не вс╕ традиц╕йн╕
	верс╕╖ вм╕ють це робити. Л╕накс користу╓ться т╕льки GNU
	верс╕╓ю \cmd{tar}.

	Якщо Ваша коп╕я не пом╕ща╓ться на одну стр╕чку, треба
	користуватися опц╕╓ю для створення багатотомних арх╕в╕в
	\texttt{--multi-volume} (\texttt{-M}):
		%
		\begin{quote}\tt
\# tar -cMf /dev/fd0H1440 /usr/src \\
tar: Removing leading / from absolute path names in the archive \\
Prepare volume \#2 for /dev/fd0H1440 and hit return:  \\
\# 
		\rm\end{quote}
		%
	В╕дм╕тьте, що Ви ма╓те в╕дформатувати дискети перш, н╕ж робити
	коп╕ювання, або ж ╕накше скористуватися ╕ншим в╕кном чи
	в╕ртуальним терм╕налом для форматування, коли \cmd{tar}
	запита╓ про наступну дискету.
	
	П╕сля того, як Ви зак╕нчили робити коп╕ювання перев╕рте
	правильн╕сть зроблено╖ коп╕╖, користуючись опц╕╓ю
	\texttt{--commpare} (\texttt{-d}):
		%
		\begin{quote}\tt
\# tar --compare --verbose -f /dev/ftape \\
usr/src/ \\
usr/src/linux \\
usr/src/linux-1.2.10-includes/ \\
.... \\
\#
		\rm\end{quote}
		%
	Якщо Ви не перев╕рите зроблену коп╕ю, то можливо Ви не
	знатимете, що Ваша коп╕я не працю╓ аж до того часу, поки Ви не
	втратите важлив╕ дан╕. 

	Доповнююч╕ коп╕╖ можна створювати за допомогою \cmd{tar} та
	опц╕╖ \texttt{--newer} (\texttt{-N}):
		%
		\begin{quote}\tt
\# tar --create --newer '8 Sep 1995' --file /dev/ftape /usr/src --verbose \\
tar: Removing leading / from absolute path names in the archive \\
usr/src/ \\
usr/src/linux-1.2.10-includes/ \\
usr/src/linux-1.2.10-includes/include/ \\
usr/src/linux-1.2.10-includes/include/linux/ \\
usr/src/linux-1.2.10-includes/include/linux/modules/ \\
usr/src/linux-1.2.10-includes/include/asm-generic/ \\
usr/src/linux-1.2.10-includes/include/asm-i386/ \\
usr/src/linux-1.2.10-includes/include/asm-mips/ \\
usr/src/linux-1.2.10-includes/include/asm-alpha/ \\
usr/src/linux-1.2.10-includes/include/asm-m68k/ \\
usr/src/linux-1.2.10-includes/include/asm-sparc/ \\
usr/src/patch-1.2.11.gz \\
\# 
		\rm\end{quote}
		%

	На жаль \cmd{tar} не може визначити, коли ╕нформац╕я, що
	м╕ститься в inode зм╕нилася, наприклад, коли б╕ти дозвол╕в на
	файл зм╕нилися, або, нав╕ть, якщо назва файлу зм╕нилася. Ц╕
	проблеми можна об╕йти, якщо скористуватися командою \cmd{find}
	та пор╕вняти поточну файлову систему ╕з списком заарх╕вованих
	файл╕в. Деяк╕ програми та скрипти для Л╕накса, як╕ вм╕ють це
	робити можна знайти на р╕зних ftp серверах.
	
\subsection{В╕дновлення файл╕в за допомогою \cmd{tar}}

	Файли з арх╕ву в╕дновлюються за допомогою опц╕╖
	\texttt{--extract} \cmd{tar}'у:
		%
		\begin{quote}\tt
\# tar --extract --same-permissions --verbose --file /dev/fd0H1440 \\
usr/src/ \\
usr/src/linux \\
usr/src/linux-1.2.10-includes/ \\
usr/src/linux-1.2.10-includes/include/ \\
usr/src/linux-1.2.10-includes/include/linux/ \\
usr/src/linux-1.2.10-includes/include/linux/hdreg.h \\
usr/src/linux-1.2.10-includes/include/linux/kernel.h \\
... \\
\#  
		\rm\end{quote}
		%

	Кр╕м того, якщо Ви вкажете назви файл╕в (чи директор╕й) в
	командному рядку, \cmd{tar} розарх╕ву╓ т╕льки вказан╕ файли та
	директор╕╖ (разом з ус╕ма файлами та п╕ддиректор╕ями всередин╕
	них): 
		%
		\begin{quote}\tt
\# tar xpvf /dev/fd0H1440 usr/src/linux-1.2.10-includes/include/linux/hdreg.h \\
usr/src/linux-1.2.10-includes/include/linux/hdreg.h \\
\# 
		\rm\end{quote}
		%

	Якщо Ви хочете переглянути, як╕ файли маються в арх╕в╕,
	користуйтеся опц╕╓ю \texttt{--list} (\texttt{-t}):
		%
		\begin{quote}\tt
\# tar --list --file /dev/fd0H1440  \\
usr/src/ \\
usr/src/linux \\
usr/src/linux-1.2.10-includes/ \\
usr/src/linux-1.2.10-includes/include/ \\
usr/src/linux-1.2.10-includes/include/linux/ \\
usr/src/linux-1.2.10-includes/include/linux/hdreg.h \\
usr/src/linux-1.2.10-includes/include/linux/kernel.h \\
... \\
\#  
		\rm\end{quote}
		%

	Майте на уваз╕, що \cmd{tar} завжди чита╓ створен╕ арх╕ви
	посл╕довно - в╕д початку до к╕нця. Тобто, з великими
	арх╕вами в╕н працю╓ досить пов╕льно. Але користуватися
	дов╕льним доступом для стр╕чок чи ╕нших пристро╖в з
	посл╕довним доступом неможливо. 

	\cmd{tar} не може в╕рно поводитися ╕з стертими файлами. Якщо
	Вам потр╕бно в╕дновити файлову систему з повно╖ та доповнюючо╖
	коп╕╖, ╕ Ви стерли к╕лька файл╕в у пром╕жку м╕ж створенням
	двох коп╕й, вони знову будуть ╕снувати п╕сля того, як ви
	в╕дновите файлову систему. Це може бути великою проблемою,
	якщо у файл╕ м╕стяться так╕ дан╕, як╕ не повинн╕ вже бути
	присутн╕ми. 
	
\section{Багатор╕внев╕ коп╕╖}

	Просте резервування описане попередньо достатн╓ в б╕льшост╕
	випадк╕в для персонального вжитку, або для невеликих
	центр╕в. Для б╕льш "<важкого"> застосування необх╕дне вживання
	багатор╕вневого резервного коп╕ювання. 

	Простий метод ма╓ два р╕вн╕ коп╕ювання: повний та
	доповнюючий. Це поняття можна узагальнити на дов╕льну
	к╕льк╕сть р╕вн╕в. Повна коп╕я буде носити назву коп╕╖ р╕вня~0,
	доповнююч╕ коп╕╖ називатимуться коп╕ями р╕вн╕в~1, 2, 3, \dots
	При кожному доповнюючому коп╕юванн╕, Ви арх╕ву╓те все, що
	зм╕нилося з часу попередньо╖ коп╕╖ такого-ж або попереднього
	р╕вня.

	Призначення тако╖ системи резервування в тому, що вона
	дозволя╓ довшу \defin{╕стор╕ю резервування \intnote{backup
	history}} дешевими засобами. В попередньому приклад╕ ╕стор╕я
	резервування йшла назад до часу попереднього повного
	резервування. ╥╖ (╕стор╕ю) можна подовжити т╕льки за рахунок
	придбання додаткових стр╕чок, по одн╕й стр╕чц╕ на тиждень, але
	це може бути занадто дорого. Довша ╕стор╕я коп╕й корисна,
	оск╕льки з╕псован╕ чи зникл╕ файли не завжди виявляються
	швидко. Тому, нав╕ть верс╕я файлу, що трохи стар╕ша, н╕ж
	хот╕лося б, краще, н╕ж н╕якого файлу зовс╕м. 

	З багатор╕вневим коп╕юванням ╕стор╕ю резервування можна
	подовжити дешевшими засобами. Наприклад, якщо купити десять
	стр╕чок, то можна використовувати стр╕чки~1 та~2 для
	щом╕сячних коп╕й (перша п'ятниця кожного м╕сяця), стр╕чки з~3
	по~6 для щотижневих коп╕й (╕нш╕ п'ятниц╕; В╕дм╕тьте, що м╕сяць
	може мати п'ять п'ятниць. Тому нам потр╕бно чотири стр╕чки), а
	стр╕чки з~7 по~10 для щоденних коп╕й (з понед╕лка до
	четверга). Всього з чотирма новими стр╕чками ми, таким чином,
	змогли подовжити глибину резевних коп╕й в╕д двох тижн╕в (п╕сля
	того, як вс╕ денн╕ стр╕чки використан╕) до двох
	м╕сяц╕в. Звичайно, ж ми не зможемо в╕дновити будь-яку верс╕ю
	будь-якого файлу на протяз╕ цих двох м╕сяц╕в, але те, що можна
	в╕дновити, часто виявля╓ться достатн╕м.

	Рисунок~\ref{fig:backup-history-timeline} показу╓, який р╕вень
	резервування використову╓ться кожного дня, ╕ як╕ коп╕╖ можуть
	бути в╕дновленими в к╕нц╕ м╕сяця. 

	\begin{figure}[t]
	\begin{center}
	\includegraphics{backups/backup-timeline.ps}
	\end{center}
	\caption{Проста багатор╕внема схема резервування.}
	\label{fig:backup-history-timeline}
	\end{figure}

	Р╕вн╕ резервування можна також використовувати для зменшення
	часу в╕дновлення файлово╖ системи до м╕н╕муму. Якщо Ви ма╓те
	батато доповнюючих коп╕й ╕з стало зростаючими номерами, Вам
	потр╕бно в╕дновити вс╕ з них, щоб повн╕стю в╕дновити файлову
	систему. Зам╕сть цього, якщо скористатися номерами р╕вн╕в
	резервування, як╕ не монотонн╕, можна скоротити к╕льк╕сть
	коп╕й, як╕ потр╕бн╕ для в╕дновлення вс╕╓╖ файлово╖ системи. 

	Щоб зменшити к╕льк╕сть необх╕дних для повного в╕дновлення
	стр╕чок, треба користуватися меншими номерами для кожного
	наступного доповнюючого резервування. Однак, в цьому випадку,
	час для створення кожно╖ тако╖ коп╕╖ зб╕льшу╓ться (кожне
	резервування коп╕ю╓ все з часу попереднього повного
	резервування). Стор╕нка п╕дказки до команди \cmd{dump} пода╓
	кращу схему резервування, яка подана в
	таблиц╕~~\ref{tab:efficient-backup-levels}. Користуйтеся такою
	посл╕довн╕стю стр╕чок: 3, 2, 5, 4, 7, 6, 9, 8, 9\dots Така
	схема утриму╓ час створення коп╕й ╕ в╕дновлення на
	м╕н╕мум╕. Максимум, що Вам потр╕бно резервувати, це результати
	дводенно╖ роботи. К╕льк╕сть стр╕чок для в╕дновлення залежить
	в╕д того, наск╕льки довго часу проходить м╕ж повними
	коп╕юваннями, але ця к╕льк╕сть менша, н╕ж при використанн╕
	простих посл╕довнестей. 


\begin{figure}[htb]
\caption{Ефективна схема резервування з використанням багатор╕вневого коп╕ювання}
\label{tab:efficient-backup-levels}
\begin{center}
\begin{tabular}{r l l l}
Tape &	Level &	Backup&	Restore \\
&	&	(days)&	tapes \\
\hline
1 &	0 &	n/a &	1 \\
2 &	3 &	1 &	1, 2 \\
3 &	2 &	2 &	1, 3 \\
4 &	5 &	1 &	1, 2, 4 \\
5 &	4 &	2 &	1, 2, 5 \\
6 &	7 &	1 &	1, 2, 5, 6 \\
7 &	6 &	2 &	1, 2, 5, 7 \\
8 &	9 &	1 &	1, 2, 5, 7, 8 \\
9 &	8 &	2 &	1, 2, 5, 7, 9 \\
10 &	9 &	1 &	1, 2, 5, 7, 9, 10 \\
11 &	9 &	1 &	1, 2, 5, 7, 9, 10, 11 \\
\dots &	9 &	1 &	1, 2, 5, 7, 9, 10, 11, \dots \\
\hline
\end{tabular}
\end{center}
\end{figure}
			
	Гарна схема, звичайно ж, може зменшити к╕льк╕сть роботи, але
	це означа╓, що ╓ багато речей, про як╕ треба пам'ятати. ╤ Ви
	повинн╕ вир╕шити, чи ця схема варта того. 

	\cmd{dump} п╕дтриму╓ багатор╕вневе резервування. Для \cmd{tar}
	та \cmd{cpio} це треба робити за допомогою скрипт╕в. 
	
\section{Що арх╕вувати}

	Звичайно ж треба створювати резервн╕ коп╕╖ з якнайб╕льшо╖
	к╕лькост╕ файл╕в. Основн╕ виключення - це програми, як╕ можна
	легко перевстановити,\footnote{Ви повинн╕ сам╕ вир╕шувати, що
	означа╓ "<легко"> для Вас. Для деяких людей перевстановлення з
	десятк╕в дискет - легко} але нав╕ть ц╕ програми можуть мати
	файли конф╕╜урац╕╖, як╕ треба арх╕вувати, якщо Ви не бажа╓те
	робити всю конф╕╜урац╕ю з самого початку. ╤нше основне
	виключення з схеми резервування - це файлова система
	\fn{proc}, оск╕льки вона завжди ма╓ т╕льки т╕ дан╕, що
	автоматично з╜енерован╕ ядром системи п╕д час роботи, ╕
	арх╕вувати ╖х \emph{ завжди} було ╕ буде нездоровою
	╕де╓ю. Особливо непотр╕бен файл \fn{/proc/kcore}, оск╕льки це
	- всього лиш образ оперативно╖ пам'ят╕ комп'ютера, ╕ до того ж
	досить великий образ.

	С╕р╕ област╕ - це новини, ло╜-файли (файли ре╓страц╕╖) та
	багато чого в \fn{/var}. Ви повинн╕ вир╕шити, що з них
	важливе. 

	Явн╕ реч╕, як╕ потребують арх╕вац╕╖ - це файли в домашн╕х
	директор╕ях користувач╕в (\fn{/home}) та системн╕ файли
	конф╕╜урац╕╖ в \fn{/etc}, але можливо ╕нш╕ файли можуть бути
	розкиданими по вс╕х файлових системах. 

\section{Резервування з компрес╕╓ю}

	Резервування займа╓ пр╕рву м╕сця, яке, в свою чергу, може
	коштувати пр╕рву грошей. Щоб зменшити об'╓м зарезервованих
	даних можна скористуватися програмами для компресування
	даних. ╢ к╕лька шлях╕в для цього. Деяк╕ програми самост╕йно
	можуть п╕дтримувати компресування даних; наприклад,  опц╕я
	\texttt{--gzip} (\texttt{-z}) для GNU \cmd{tar} в╕дправля╓ вс╕
	дан╕ через канал (pipe) до програми компрес╕╖
	\cmd{gzip}, перш, н╕ж записати дан╕ на нос╕й.

	На жаль, арх╕вування з компрес╕╓ю може спричинити
	проблеми. Механ╕зм роботи програм компрес╕╖ приводить до того,
	що, якщо хоча б один б╕т в арх╕в╕ псу╓ться ╕ ста╓ нев╕рним, то
	╕ весь арх╕в ста╓ нев╕рним. Деяк╕ програми компрес╕╖ мають
	вбудован╕ механ╕зми корекц╕╖ помилок, але не ╕сну╓ такого
	методу, який би м╕г справитися з великою к╕льк╕стю помилок. Це
	означа╓, що якщо резервна коп╕я скомпресована тим чином, яким
	це робить GNU \cmd{tar}, тобто коли весь арх╕в компресу╓ться
	як одне ц╕ле, то ╓дина помилка в арх╕вац╕╖ може привести до
	того, що вся коп╕я буде загублена. Резервн╕ коп╕╖ мають бути
	над╕йними, ╕ тому такий метод компрес╕╖ не дуже гарна ╕дея. 
	
	Альтернативою може бути компресування файл╕в поодинц╕. Це
	означа╓, що якщо нав╕ть один файл втрачено, вс╕ ╕нш╕ будуть
	ц╕л╕. Загублений файл м╕г би бути з╕псованим все одно, нав╕ть
	без компрес╕╖, тому цей п╕дх╕д до арх╕вування не набагато
	г╕рший в╕д того, коли компрес╕я не використову╓ться
	зовс╕м. Програма \cmd{afio} (вар╕ант команди \cmd{cpio}) вм╕╓
	це робити. 
	
	Компресування займа╓ деякий час, що може привести до того, що
	програма арх╕вування не зможе записувати дан╕ на стр╕чку з
	потр╕бною швидк╕стю.\footnote{Якщо прив╕д стр╕чки не отриму╓
	дан╕ з достатньою швидк╕стю, в╕н повинен зупинитися, це
	призводить до того, що арх╕вування ста╓ ще пов╕льн╕шим, ╕, в
	той же час може бути поганим для приводу ╕ для стр╕чки.} Цього
	можна позбутися, якщо пропускати дан╕ через буфер (або
	внутр╕шн╕й, якщо програма достатньо для цього розумна, або
	використовуючи ╕ншу програму), але нав╕ть в цьому випадку
	арх╕вац╕я може не працювати, так як треба. Це може, однак,
	бути проблемою т╕льки на пов╕льних комп'ютерах.

